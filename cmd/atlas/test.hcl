function "public" "get_table_ddl" {
  schema     = schema.public
  args       = "in_schema character varying, in_table character varying, bfkeys boolean"
  returns    = "text"
  language   = "plpgsql"
  definition = "AS $function$\r\n  DECLARE\r\n    -- the ddl we're building\r\n    v_table_ddl text;\r\n\r\n    -- data about the target table\r\n    v_table_oid int;\r\n\r\n    -- records for looping\r\n    v_colrec record;\r\n    v_constraintrec record;\r\n    v_indexrec record;\r\n    v_primary boolean := False;\r\n    v_constraint_name text;\r\n    v_src_path_old text := '';\r\n    v_src_path_new text := '';\r\n    v_dummy text;\r\n    v_partbound text;\r\n    v_pgversion int;\r\n    v_parent     text := '';\r\n    v_relopts text := '';\r\n    v_tablespace text;\r\n    v_partition_key text := '';\r\n    v_temp       text;\r\n    bPartitioned bool := False;\r\n    bInheritance bool := False;\r\n    bRelispartition bool;\r\n    constraintarr text[] := '{}';\r\n    constraintelement text;\r\n    bSkip boolean;\r\n\r\n  BEGIN\r\n    SELECT c.oid, (\r\n        SELECT setting\r\n        FROM pg_settings\r\n        WHERE name = 'server_version_num') INTO v_table_oid, v_pgversion\r\n    FROM pg_catalog.pg_class c\r\n        LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\r\n    WHERE c.relkind IN ('r', 'p')\r\n        AND c.relname = in_table\r\n        AND n.nspname = in_schema;\r\n    IF (v_table_oid IS NULL) THEN\r\n      RAISE EXCEPTION 'table does not exist';\r\n    END IF;\r\n\r\n    -- get user-defined tablespaces if applicable\r\n    SELECT TABLESPACE INTO v_temp\r\n    FROM pg_tables\r\n    WHERE schemaname = in_schema\r\n        AND tablename = in_table\r\n        AND TABLESPACE IS NOT NULL;\r\n    -- Issue#99 Fix: simple coding error!\r\n    -- IF v_tablespace IS NULL THEN\r\n    IF v_temp IS NULL THEN\r\n      v_tablespace := 'TABLESPACE pg_default';\r\n    ELSE\r\n      v_tablespace := 'TABLESPACE ' || v_temp;\r\n    END IF;\r\n    -- also see if there are any SET commands for this table, ie, autovacuum_enabled=off, fillfactor=70\r\n    WITH relopts AS (\r\n        SELECT unnest(c.reloptions) relopts\r\n        FROM pg_class c, pg_namespace n\r\n        WHERE n.nspname = in_schema\r\n            AND n.oid = c.relnamespace\r\n            AND c.relname = in_table\r\n    )\r\n    SELECT string_agg(r.relopts, ', ') AS relopts INTO v_temp\r\n    FROM relopts r;\r\n    IF v_temp IS NULL THEN\r\n      v_relopts := '';\r\n    ELSE\r\n      v_relopts := ' WITH (' || v_temp || ')';\r\n    END IF;\r\n\r\n    -- Issue#61 FIX: set search_path = public before we do anything to force explicit schema qualification but dont forget to set it back before exiting...\r\n    SELECT setting INTO v_src_path_old FROM pg_settings WHERE name = 'search_path';\r\n\r\n    SELECT REPLACE(REPLACE(setting, '\"$user\"', '$user'), '$user', '\"$user\"') INTO v_src_path_old\r\n    FROM pg_settings\r\n    WHERE name = 'search_path';\r\n    -- RAISE INFO 'DEBUG tableddl: saving old search_path: ***%***', v_src_path_old;\r\n    EXECUTE 'SET search_path = \"public\"';\r\n    SELECT setting INTO v_src_path_new FROM pg_settings WHERE name = 'search_path';\r\n\r\n    -- grab the oid of the table; https://www.postgresql.org/docs/8.3/catalog-pg-class.html\r\n    SELECT c.oid INTO v_table_oid\r\n    FROM pg_catalog.pg_class c\r\n        LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\r\n    WHERE 1 = 1\r\n        AND c.relkind = 'r'\r\n        AND c.relname = in_table\r\n        AND n.nspname = in_schema;\r\n\r\n    IF (v_table_oid IS NULL) THEN\r\n      -- Dont give up yet.  It might be a partitioned table\r\n      SELECT c.oid INTO v_table_oid\r\n      FROM pg_catalog.pg_class c\r\n          LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\r\n      WHERE 1 = 1\r\n          AND c.relkind = 'p'\r\n          AND c.relname = in_table\r\n          AND n.nspname = in_schema;\r\n\r\n      IF (v_table_oid IS NULL) THEN\r\n        RAISE EXCEPTION 'table does not exist';\r\n      END IF;\r\n      bPartitioned := True;\r\n    END IF;\r\n    IF v_pgversion < 100000 THEN\r\n      SELECT c2.relname parent INTO v_parent\r\n      FROM pg_class c1, pg_namespace n, pg_inherits i, pg_class c2\r\n      WHERE n.nspname = in_schema\r\n          AND n.oid = c1.relnamespace\r\n          AND c1.relname = in_table\r\n          AND c1.oid = i.inhrelid\r\n          AND i.inhparent = c2.oid\r\n          AND c1.relkind = 'r';\r\n\r\n      IF (v_parent IS NOT NULL) THEN\r\n        bPartitioned := True;\r\n        bInheritance  := True;\r\n      END IF;\r\n    ELSE\r\n      SELECT c2.relname parent, c1.relispartition, pg_get_expr(c1.relpartbound, c1.oid, TRUE) INTO v_parent, bRelispartition, v_partbound\r\n      FROM pg_class c1, pg_namespace n, pg_inherits i, pg_class c2\r\n      WHERE n.nspname = in_schema\r\n          AND n.oid = c1.relnamespace\r\n          AND c1.relname = in_table\r\n          AND c1.oid = i.inhrelid\r\n          AND i.inhparent = c2.oid\r\n          AND c1.relkind = 'r';\r\n\r\n      IF (v_parent IS NOT NULL) THEN\r\n        bPartitioned   := True;\r\n        IF bRelispartition THEN\r\n          bInheritance := False;\r\n        ELSE\r\n          bInheritance := True;\r\n        END IF;\r\n      END IF;\r\n    END IF;\r\n    -- RAISE NOTICE 'version=%  schema=%  parent=%  relopts=%  tablespace=%  partitioned=%  inherited=%  relispartition=%',v_pgversion, in_schema, v_parent, v_relopts, v_tablespace, bPartitioned, bInheritance,   bRelispartition;\r\n\r\n    -- start the create definition\r\n    v_table_ddl := 'CREATE TABLE ' || in_schema || '.' || in_table || ' (' || E'\\n';\r\n\r\n    -- define all of the columns in the table; https://stackoverflow.com/a/8153081/3068233\r\n    FOR v_colrec IN\r\n      SELECT c.column_name, c.data_type, c.udt_name, c.character_maximum_length, c.is_nullable, c.column_default, c.numeric_precision, c.numeric_scale, c.is_identity, c.identity_generation\r\n      FROM information_schema.columns c\r\n      WHERE (table_schema, table_name) = (in_schema, in_table)\r\n      ORDER BY ordinal_position\r\n    LOOP\r\n      v_table_ddl := v_table_ddl || '  ' -- note: two char spacer to start, to indent the column\r\n        || v_colrec.column_name || ' '\r\n        --FIX #82, FIX #100 as well by adding 'citext' to the list\r\n        -- EXECUTE. 42704. type \"<targetschema>.citext\" does not exist\r\n        -- || CASE WHEN v_colrec.data_type = 'USER-DEFINED' THEN in_schema || '.' || v_colrec.udt_name ELSE v_colrec.data_type END\r\n        -- || CASE WHEN v_colrec.udt_name in ('geometry', 'box2d', 'box2df', 'box3d', 'geography', 'geometry_dump', 'gidx', 'spheroid', 'valid_detail')\r\n        || CASE WHEN v_colrec.udt_name in ('geometry', 'box2d', 'box2df', 'box3d', 'geography', 'geometry_dump', 'gidx', 'spheroid', 'valid_detail','citext')\r\n           THEN v_colrec.udt_name WHEN v_colrec.data_type = 'USER-DEFINED' THEN in_schema || '.' || v_colrec.udt_name ELSE v_colrec.data_type END \r\n        || CASE WHEN v_colrec.is_identity = 'YES' THEN CASE WHEN v_colrec.identity_generation = 'ALWAYS' THEN ' GENERATED ALWAYS AS IDENTITY' ELSE ' GENERATED BY DEFAULT AS IDENTITY' END ELSE '' END\r\n        || CASE WHEN v_colrec.character_maximum_length IS NOT NULL THEN ('(' || v_colrec.character_maximum_length || ')')\r\n                WHEN v_colrec.numeric_precision > 0 AND v_colrec.numeric_scale > 0 THEN '(' || v_colrec.numeric_precision || ',' || v_colrec.numeric_scale || ')'\r\n           ELSE '' END || ' '\r\n        || CASE WHEN v_colrec.is_nullable = 'NO' THEN 'NOT NULL' ELSE 'NULL' END\r\n        || CASE WHEN v_colrec.column_default IS NOT null THEN (' DEFAULT ' || v_colrec.column_default) ELSE '' END\r\n        || ',' || E'\\n';\r\n    END LOOP;\r\n    -- define all the constraints in the; https://www.postgresql.org/docs/9.1/catalog-pg-constraint.html && https://dba.stackexchange.com/a/214877/75296\r\n    -- Issue#103: do not get foreign keys for partitions since they are defined on the parent and this will cause an \"already exists\" error otherwise\r\n    --            Also conparentid is not in V10, so bypass since we do not have FKEYS in partitioned tables in V10\r\n    IF v_pgversion < 110000 THEN\r\n      FOR v_constraintrec IN\r\n        SELECT\r\n          con.conname as constraint_name,\r\n          con.contype as constraint_type,\r\n          CASE\r\n            WHEN con.contype = 'p' THEN 1 -- primary key constraint\r\n            WHEN con.contype = 'u' THEN 2 -- unique constraint\r\n            WHEN con.contype = 'f' THEN 3 -- foreign key constraint\r\n            WHEN con.contype = 'c' THEN 4\r\n            ELSE 5\r\n          END as type_rank,\r\n          pg_get_constraintdef(con.oid) as constraint_definition\r\n        FROM pg_catalog.pg_constraint con\r\n            JOIN pg_catalog.pg_class rel ON rel.oid = con.conrelid\r\n            JOIN pg_catalog.pg_namespace nsp ON nsp.oid = connamespace\r\n        WHERE nsp.nspname = in_schema\r\n            AND rel.relname = in_table\r\n            ORDER BY type_rank\r\n      LOOP\r\n        -- Issue#85 fix\r\n        -- constraintarr := constraintarr || v_constraintrec.constraint_name;\r\n        constraintarr := constraintarr || v_constraintrec.constraint_name::text;\r\n        IF v_constraintrec.type_rank = 1 THEN\r\n            v_primary := True;\r\n            v_constraint_name := v_constraintrec.constraint_name;\r\n        END IF;\r\n        IF NOT bfkeys AND v_constraintrec.constraint_type = 'f' THEN\r\n            continue;\r\n        END IF;\r\n        v_table_ddl := v_table_ddl || '  ' -- note: two char spacer to start, to indent the column\r\n          || 'CONSTRAINT' || ' '\r\n          || v_constraintrec.constraint_name || ' '\r\n          || v_constraintrec.constraint_definition\r\n          || ',' || E'\\n';\r\n      END LOOP;\r\n    ELSE\r\n      FOR v_constraintrec IN\r\n        SELECT\r\n          con.conname as constraint_name,\r\n          con.contype as constraint_type,\r\n          CASE\r\n            WHEN con.contype = 'p' THEN 1 -- primary key constraint\r\n            WHEN con.contype = 'u' THEN 2 -- unique constraint\r\n            WHEN con.contype = 'f' THEN 3 -- foreign key constraint\r\n            WHEN con.contype = 'c' THEN 4\r\n            ELSE 5\r\n          END as type_rank,\r\n          pg_get_constraintdef(con.oid) as constraint_definition\r\n        FROM pg_catalog.pg_constraint con\r\n            JOIN pg_catalog.pg_class rel ON rel.oid = con.conrelid\r\n            JOIN pg_catalog.pg_namespace nsp ON nsp.oid = connamespace\r\n        WHERE nsp.nspname = in_schema\r\n            AND rel.relname = in_table\r\n            -- Issue#103: do not get partitioned tables\r\n            AND con.conparentid = 0\r\n        ORDER BY type_rank\r\n      LOOP\r\n        -- Issue#85 fix\r\n        -- constraintarr := constraintarr || v_constraintrec.constraint_name;\r\n        constraintarr := constraintarr || v_constraintrec.constraint_name::text;\r\n        IF v_constraintrec.type_rank = 1 THEN\r\n            v_primary := True;\r\n            v_constraint_name := v_constraintrec.constraint_name;\r\n        END IF;\r\n        IF NOT bfkeys AND v_constraintrec.constraint_type = 'f' THEN\r\n            continue;\r\n        END IF;\r\n        v_table_ddl := v_table_ddl || '  ' -- note: two char spacer to start, to indent the column\r\n          || 'CONSTRAINT' || ' '\r\n          || v_constraintrec.constraint_name || ' '\r\n          || v_constraintrec.constraint_definition\r\n          || ',' || E'\\n';\r\n      END LOOP;\r\n    END IF;\r\n    \r\n    -- drop the last comma before ending the create statement\r\n    v_table_ddl = substr(v_table_ddl, 0, length(v_table_ddl) - 1) || E'\\n';\r\n    -- end the create table def but add inherits clause if valid\r\n    IF bPartitioned and bInheritance THEN\r\n      v_table_ddl := v_table_ddl || ') INHERITS (' || in_schema || '.' || v_parent || ') ' || v_relopts || ' ' || v_tablespace || ';' || E'\\n';\r\n    ELSIF v_pgversion >= 100000 AND bPartitioned and NOT bInheritance THEN\r\n      -- See if this is a partitioned table (pg_class.relkind = 'p') and add the partitioned key\r\n      SELECT pg_get_partkeydef (c1.oid) AS partition_key INTO v_partition_key\r\n      FROM pg_class c1\r\n          JOIN pg_namespace n ON (n.oid = c1.relnamespace)\r\n          LEFT JOIN pg_partitioned_table p ON (c1.oid = p.partrelid)\r\n      WHERE n.nspname = in_schema\r\n          AND n.oid = c1.relnamespace\r\n          AND c1.relname = in_table\r\n          AND c1.relkind = 'p';\r\n    END IF;\r\n    IF v_partition_key IS NOT NULL AND v_partition_key <> '' THEN\r\n      -- add partition clause\r\n      -- NOTE:  cannot specify default tablespace for partitioned relations\r\n      v_table_ddl := v_table_ddl || ') PARTITION BY ' || v_partition_key || ';' || E'\\n';\r\n    ELSIF bPartitioned AND not bInheritance THEN\r\n      IF v_relopts <> '' THEN\r\n        v_table_ddl := 'CREATE TABLE ' || in_schema || '.' || in_table || ' PARTITION OF ' || in_schema || '.' || v_parent || ' ' || v_partbound || v_relopts || ' ' || v_tablespace || '; ' || E'\\n';\r\n      ELSE\r\n        v_table_ddl := 'CREATE TABLE ' || in_schema || '.' || in_table || ' PARTITION OF ' || in_schema || '.' || v_parent || ' ' || v_partbound || ' ' || v_tablespace || '; ' || E'\\n';\r\n      END IF;\r\n    ELSIF bPartitioned and bInheritance THEN\r\n      -- we already did this above\r\n      v_table_ddl := v_table_ddl;\r\n    ELSIF v_relopts <> '' THEN\r\n      v_table_ddl := v_table_ddl || ') ' || v_relopts || ' ' || v_tablespace || ';' || E'\\n';\r\n    ELSE\r\n      v_table_ddl := v_table_ddl || ') ' || v_tablespace || ';' || E'\\n';\r\n    END IF;\r\n    -- suffix create statement with all of the indexes on the table\r\n    FOR v_indexrec IN\r\n      SELECT indexdef, indexname\r\n      FROM pg_indexes\r\n      WHERE (schemaname, tablename) = (in_schema, in_table)\r\n    LOOP\r\n      -- Issue#83 fix: loop through constraints and skip ones already defined\r\n      bSkip = False;\r\n      FOREACH constraintelement IN ARRAY constraintarr\r\n      LOOP \r\n         IF constraintelement = v_indexrec.indexname THEN\r\n             bSkip = True;\r\n             EXIT;\r\n         END IF;\r\n      END LOOP;   \r\n      if bSkip THEN CONTINUE; END IF;\r\n      v_table_ddl := v_table_ddl\r\n        || v_indexrec.indexdef\r\n        || ';' || E'\\n';\r\n    END LOOP;\r\n\r\n    -- reset search_path back to what it was\r\n    IF v_src_path_old = '' THEN\r\n      SELECT set_config('search_path', '', false) into v_dummy;\r\n    ELSE\r\n      EXECUTE 'SET search_path = ' || v_src_path_old;\r\n    END IF;\r\n    -- RAISE NOTICE 'DEBUG tableddl: reset search_path back to ***%***', v_src_path_old;\r\n\r\n    -- return the ddl\r\n    RETURN v_table_ddl;\r\n  END;\r\n$function$"
}
function "public" "jsonb_recursive_merge" {
  schema     = schema.public
  args       = "a jsonb, b jsonb"
  returns    = "jsonb"
  language   = "sql"
  definition = "AS $function$ \nSELECT \n jsonb_object_agg( \n coalesce(ka, kb), \n CASE \n WHEN va isnull THEN vb \n WHEN vb isnull THEN va \n WHEN jsonb_typeof(va) <> 'object' OR jsonb_typeof(vb) <> 'object' THEN vb \n ELSE jsonb_recursive_merge(va, vb) END \n ) \n FROM jsonb_each(A) temptable1(ka, va)\n FULL JOIN jsonb_each(B) temptable2(kb, vb) ON ka = kb \n$function$"
}
function "public" "pgaudit_ddl_command_end" {
  schema     = schema.public
  args       = ""
  returns    = "event_trigger"
  language   = "c"
  definition = "SECURITY DEFINER\n SET search_path TO 'pg_catalog, pg_temp'\nAS '$libdir/pgaudit', $function$pgaudit_ddl_command_end$function$"
}
function "public" "versioning" {
  schema     = schema.public
  args       = ""
  returns    = "trigger"
  language   = "plpgsql"
  definition = "AS $function$\r\nDECLARE\r\n  sys_period text;\r\n  history_table text;\r\n  manipulate jsonb;\r\n  ignore_unchanged_values bool;\r\n  commonColumns text[];\r\n  fidColumns text[];\r\n  time_stamp_to_use timestamptz := current_timestamp;\r\n  range_lower timestamptz;\r\n  existing_range tstzrange;\r\n  newVersion record;\r\n  oldVersion record;\r\nBEGIN\r\n\r\n\traise notice '%', TG_RELID;\r\n\traise notice '%', history_table::regclass;\r\n\r\n  sys_period := TG_ARGV[0];\r\n  history_table := TG_ARGV[1];\r\n  ignore_unchanged_values := TG_ARGV[3];\r\n\r\n\r\n  IF TG_OP = 'UPDATE' OR TG_OP = 'DELETE' THEN\r\n    -- Ignore rows already modified in the current transaction\r\n    IF OLD.xmin::text = (txid_current() % (2^32)::bigint)::text THEN\r\n      IF TG_OP = 'DELETE' THEN\r\n        RETURN OLD;\r\n      END IF;\r\n\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    EXECUTE format('SELECT $1.%I', sys_period) USING OLD INTO existing_range;\r\n\r\n    IF TG_ARGV[2] = 'true' THEN\r\n      -- mitigate update conflicts\r\n      range_lower := lower(existing_range);\r\n      IF range_lower >= time_stamp_to_use THEN\r\n        time_stamp_to_use := range_lower + interval '1 microseconds';\r\n      END IF;\r\n    END IF;\r\n\r\n    WITH history AS\r\n      (SELECT attname\r\n      FROM   pg_attribute\r\n      WHERE  attrelid = history_table::regclass\r\n      AND    attnum > 0\r\n      AND    NOT attisdropped),\r\n      main AS\r\n      (SELECT attname\r\n      FROM   pg_attribute\r\n      WHERE  attrelid = TG_RELID\r\n      AND    attnum > 0\r\n      AND    NOT attisdropped)\r\n    SELECT array_agg(quote_ident(history.attname)) INTO commonColumns\r\n      FROM history\r\n      INNER JOIN main\r\n      ON history.attname = main.attname\r\n      AND history.attname != sys_period;\r\n    -- skip version if it would be identical to the previous version\r\n    IF ignore_unchanged_values AND TG_OP = 'UPDATE' AND array_length(commonColumns, 1) > 0 THEN EXECUTE 'SELECT ROW($1.' || array_to_string(commonColumns , ', $1.') || ')'\r\n        USING NEW\r\n        INTO newVersion;\r\n      EXECUTE 'SELECT ROW($1.' || array_to_string(commonColumns , ', $1.') || ')'\r\n        USING OLD\r\n        INTO oldVersion;\r\n      IF newVersion IS NOT DISTINCT FROM oldVersion THEN\r\n        RETURN NEW;\r\n      END IF;\r\n    END IF;\r\n   \r\n   IF TG_OP='DELETE' THEN\r\n \tWITH history AS\r\n      (SELECT attname\r\n      FROM   pg_attribute\r\n      WHERE  attrelid = history_table::regclass\r\n      AND    attnum > 0\r\n      AND    NOT attisdropped),\r\n      main AS\r\n      (SELECT attname\r\n      FROM   pg_attribute\r\n      WHERE  attrelid = TG_RELID\r\n      AND    attnum > 0\r\n      AND    NOT attisdropped)\r\n    SELECT array_agg(quote_ident(history.attname)) INTO fidColumns\r\n      FROM history\r\n      INNER JOIN main\r\n      ON history.attname = main.attname\r\n      AND history.attname like 'fid_%';\r\n     \r\n     raise notice '%', fidColumns;\r\n   END IF;\r\n  \r\n   \r\n    EXECUTE ('INSERT INTO ' ||\r\n      history_table ||\r\n      '(' ||\r\n      array_to_string(commonColumns , ',') ||\r\n      ',' ||\r\n      quote_ident(sys_period) ||\r\n      ') VALUES ($1.' ||\r\n      array_to_string(commonColumns, ',$1.') ||\r\n      ',tstzrange($2, $3, ''[)''))')\r\n       USING OLD, range_lower, time_stamp_to_use;\r\n  END IF;\r\n\r\n  IF TG_OP = 'UPDATE' OR TG_OP = 'INSERT' THEN\r\n    manipulate := jsonb_set('{}'::jsonb, ('{' || sys_period || '}')::text[], to_jsonb(tstzrange(time_stamp_to_use, null, '[)')));\r\n\r\n    RETURN jsonb_populate_record(NEW, manipulate);\r\n  END IF;\r\n\r\n  RETURN OLD;\r\nEND;\r\n$function$"
}
function "public" "get_table_ddl_complex" {
  schema     = schema.public
  args       = "src_schema text, dst_schema text, in_table text, sq_server_version_num integer"
  returns    = "text"
  language   = "plpgsql"
  definition = "AS $function$\r\n  DECLARE\r\n  v_table_ddl   text;\r\n  v_buffer1     text;\r\n  v_buffer2     text;\r\n\r\n  BEGIN\r\n      IF sq_server_version_num < 110000 THEN\r\n      SELECT 'CREATE TABLE '\r\n        || quote_ident(dst_schema)\r\n        || '.'\r\n        || pc.relname\r\n        || E'(\\n'\r\n        || string_agg(\r\n          pa.attname\r\n            || ' '\r\n            || pg_catalog.format_type(pa.atttypid, pa.atttypmod)\r\n            || coalesce(\r\n              ' DEFAULT '\r\n                || (\r\n                  SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid)\r\n                  FROM pg_catalog.pg_attrdef d\r\n                  WHERE d.adrelid = pa.attrelid\r\n                    AND d.adnum = pa.attnum\r\n                    AND pa.atthasdef\r\n                ),\r\n              ''\r\n            )\r\n            || ' '\r\n            || CASE pa.attnotnull\r\n              WHEN TRUE THEN 'NOT NULL'\r\n              ELSE 'NULL'\r\n              END,\r\n          E',\\n'\r\n        )\r\n        || coalesce(\r\n          (\r\n            SELECT\r\n              E',\\n'\r\n              || string_agg(\r\n                'CONSTRAINT '\r\n                  || pc1.conname\r\n                  || ' '\r\n                  || pg_get_constraintdef(pc1.oid),\r\n                E',\\n'\r\n                ORDER BY pc1.conindid\r\n              )\r\n            FROM pg_constraint pc1\r\n            --Issue#103: do not return FKEYS for partitions since we assume it is implied by the one done on the parent table, otherwise error for trying to define it again.\r\n            WHERE pc1.conrelid = pa.attrelid \r\n          ),\r\n          ''\r\n        )\r\n      INTO v_buffer1  \r\n      FROM pg_catalog.pg_attribute pa\r\n        JOIN pg_catalog.pg_class pc ON pc.oid = pa.attrelid\r\n          AND pc.relname = quote_ident(in_table)\r\n        JOIN pg_catalog.pg_namespace pn ON pn.oid = pc.relnamespace\r\n          AND pn.nspname = quote_ident(src_schema)\r\n      WHERE pa.attnum > 0\r\n        AND NOT pa.attisdropped\r\n      GROUP BY pn.nspname, pc.relname, pa.attrelid;\r\n      \r\n      ELSE\r\n      SELECT 'CREATE TABLE '\r\n        || quote_ident(dst_schema)\r\n        || '.'\r\n        || pc.relname\r\n        || E'(\\n'\r\n        || string_agg(\r\n          pa.attname\r\n            || ' '\r\n            || pg_catalog.format_type(pa.atttypid, pa.atttypmod)\r\n            || coalesce(\r\n              ' DEFAULT '\r\n                || (\r\n                  SELECT pg_catalog.pg_get_expr(d.adbin, d.adrelid)\r\n                  FROM pg_catalog.pg_attrdef d\r\n                  WHERE d.adrelid = pa.attrelid\r\n                    AND d.adnum = pa.attnum\r\n                    AND pa.atthasdef\r\n                ),\r\n              ''\r\n            )\r\n            || ' '\r\n            || CASE pa.attnotnull\r\n              WHEN TRUE THEN 'NOT NULL'\r\n              ELSE 'NULL'\r\n              END,\r\n          E',\\n'\r\n        )\r\n        || coalesce(\r\n          (\r\n            SELECT\r\n              E',\\n'\r\n              || string_agg(\r\n                'CONSTRAINT '\r\n                  || pc1.conname\r\n                  || ' '\r\n                  || pg_get_constraintdef(pc1.oid),\r\n                E',\\n'\r\n                ORDER BY pc1.conindid\r\n              )\r\n            FROM pg_constraint pc1\r\n            --Issue#103: do not return FKEYS for partitions since we assume it is implied by the one done on the parent table, otherwise error for trying to define it again.\r\n            WHERE pc1.conrelid = pa.attrelid AND pc1.conparentid = 0 \r\n          ),\r\n          ''\r\n        )\r\n      INTO v_buffer1  \r\n      FROM pg_catalog.pg_attribute pa\r\n        JOIN pg_catalog.pg_class pc ON pc.oid = pa.attrelid\r\n          AND pc.relname = quote_ident(in_table)\r\n        JOIN pg_catalog.pg_namespace pn ON pn.oid = pc.relnamespace\r\n          AND pn.nspname = quote_ident(src_schema)\r\n      WHERE pa.attnum > 0\r\n        AND NOT pa.attisdropped\r\n      GROUP BY pn.nspname, pc.relname, pa.attrelid;\r\n      END IF;\r\n\r\n      -- append partition keyword to it\r\n      SELECT pg_catalog.pg_get_partkeydef(c.oid::pg_catalog.oid) into v_buffer2\r\n      FROM pg_catalog.pg_class c  LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace\r\n      WHERE c.relname = quote_ident(in_table) COLLATE pg_catalog.default AND n.nspname = quote_ident(src_schema) COLLATE pg_catalog.default;\r\n\r\n      v_table_ddl := v_buffer1 || ') PARTITION BY ' || v_buffer2 || ';';\r\n  \r\n      RETURN v_table_ddl;\r\n  END;\r\n$function$"
}
function "public" "get_insert_stmt_ddl" {
  schema     = schema.public
  args       = "source_schema text, target_schema text, atable text, btextcast boolean"
  returns    = "text"
  language   = "plpgsql"
  definition = "AS $function$\r\n  DECLARE\r\n    -- the ddl we're building\r\n    v_insert_ddl text := '';\r\n    v_cols       text := '';\r\n    v_cols_sel   text := '';\r\n    v_cnt        int  := 0;\r\n    v_colrec     record;\r\n    v_schema     text;\r\n  BEGIN\r\n    FOR v_colrec IN\r\n      SELECT c.column_name, c.data_type, c.udt_name, c.udt_schema, c.character_maximum_length, c.is_nullable, c.column_default, c.numeric_precision, c.numeric_scale, c.is_identity, c.identity_generation, c.is_generated \r\n      FROM information_schema.columns c WHERE (table_schema, table_name) = (source_schema, atable) ORDER BY ordinal_position\r\n    LOOP\r\n      IF v_colrec.udt_schema = 'public' THEN\r\n        v_schema = 'public';\r\n      ELSE\r\n        v_schema = target_schema;\r\n      END IF;\r\n      \r\n      v_cnt = v_cnt + 1;\r\n      IF v_colrec.is_identity = 'YES' OR v_colrec.is_generated = 'ALWAYS' THEN\r\n        -- skip\r\n        continue;\r\n      END IF;\r\n\r\n      IF v_colrec.data_type = 'USER-DEFINED' THEN\r\n        IF v_cols = '' THEN\r\n          v_cols     = v_colrec.column_name;\r\n          IF bTextCast THEN \r\n            -- v_cols_sel = v_colrec.column_name || '::text::' || v_schema || '.' || v_colrec.udt_name;\r\n            IF v_schema = 'public' THEN\r\n              v_cols_sel = v_colrec.column_name || '::' || v_schema || '.' || v_colrec.udt_name;\r\n            ELSE\r\n              v_cols_sel = v_colrec.column_name || '::text::' || v_colrec.udt_name;\r\n            END IF;\r\n          ELSE\r\n            v_cols_sel = v_colrec.column_name || '::' || v_schema || '.' || v_colrec.udt_name;\r\n          END IF;\r\n        ELSE \r\n          v_cols     = v_cols     || ', ' || v_colrec.column_name;\r\n          IF bTextCast THEN \r\n            -- v_cols_sel = v_cols_sel || ', ' || v_colrec.column_name || '::text::' || v_schema || '.' || v_colrec.udt_name;\r\n            IF v_schema = 'public' THEN\r\n              v_cols_sel = v_cols_sel || ', ' || v_colrec.column_name || '::' || v_schema || '.' || v_colrec.udt_name;\r\n            ELSE\r\n              v_cols_sel = v_cols_sel || ', ' || v_colrec.column_name || '::text::' || v_colrec.udt_name;\r\n            END IF;\r\n          ELSE\r\n            v_cols_sel = v_cols_sel || ', ' || v_colrec.column_name || '::' || v_schema || '.' || v_colrec.udt_name;\r\n          END IF;\r\n        END IF;\r\n      ELSE\r\n        IF v_cols = '' THEN\r\n          v_cols     = v_colrec.column_name;\r\n          v_cols_sel = v_colrec.column_name;\r\n        ELSE \r\n          v_cols     = v_cols     || ', ' || v_colrec.column_name;\r\n          v_cols_sel = v_cols_sel || ', ' || v_colrec.column_name;\r\n        END IF;\r\n      END IF;\r\n    END LOOP;\r\n\r\n    -- put it all together and return the insert statement\r\n    -- INSERT INTO clone1.address2 (id2, id3, addr) SELECT id2::text::clone1.udt_myint, id3::text::clone1.udt_myint, addr FROM sample.address;    \r\n    v_insert_ddl = 'INSERT INTO ' || target_schema || '.' || atable || ' (' || v_cols || ') ' || 'SELECT ' || v_cols_sel || ' FROM ' || source_schema || '.' || atable || ';';\r\n    RETURN v_insert_ddl;\r\n  END;\r\n$function$"
}
function "public" "clone_schema" {
  schema     = schema.public
  args       = "source_schema text, dest_schema text, VARIADIC arr cloneparms[]"
  returns    = "void"
  language   = "plpgsql"
  definition = "AS $function$\r\n\r\n--  This function will clone all sequences, tables, data, views & functions from any existing schema to a new one\r\n-- SAMPLE CALL:\r\n-- SELECT clone_schema('sample', 'sample_clone2');\r\n\r\nDECLARE\r\n  src_oid          oid;\r\n  tbl_oid          oid;\r\n  func_oid         oid;\r\n  object           text;\r\n  buffer           text;\r\n  buffer2          text;\r\n  buffer3          text;\r\n  srctbl           text;\r\n  aname            text;\r\n  default_         text;\r\n  column_          text;\r\n  qry              text;\r\n  ix_old_name      text;\r\n  ix_new_name      text;\r\n  relpersist       text;\r\n  udt_name         text;\r\n  bRelispart       bool;\r\n  bChild           bool;\r\n  relknd           text;\r\n  data_type        text;\r\n  ocomment         text;\r\n  adef             text;\r\n  dest_qry         text;\r\n  v_def            text;\r\n  part_range       text;\r\n  src_path_old     text;\r\n  src_path_new     text;\r\n  aclstr           text;\r\n  -- issue#80 initialize arrays properly\r\n  tblarray         text[] := '{}';\r\n  tblarray2        text[] := '{}';\r\n  tblarray3        text[] := '{}';\r\n  tblelement       text;\r\n  grantor          text;\r\n  grantee          text;\r\n  privs            text;\r\n  seqval           bigint;\r\n  sq_last_value    bigint;\r\n  sq_max_value     bigint;\r\n  sq_start_value   bigint;\r\n  sq_increment_by  bigint;\r\n  sq_min_value     bigint;\r\n  sq_cache_value   bigint;\r\n  sq_is_called     boolean := True;\r\n  sq_is_cycled     boolean;\r\n  is_prokind       boolean;\r\n  abool            boolean;\r\n  sq_data_type     text;\r\n  sq_cycled        char(10);\r\n  sq_owned         text;\r\n  sq_version        text;\r\n  sq_server_version text;\r\n  sq_server_version_num integer;\r\n  bWindows         boolean;\r\n  arec             RECORD;\r\n  cnt              integer;\r\n  cnt2             integer;\r\n  cnt3             integer;\r\n  pos              integer;\r\n  tblscopied       integer := 0;\r\n  l_child          integer;\r\n  action           text := 'N/A';\r\n  tblname          text;\r\n  v_ret            text;\r\n  v_diag1          text;\r\n  v_diag2          text;\r\n  v_diag3          text;\r\n  v_diag4          text;\r\n  v_diag5          text;\r\n  v_diag6          text;\r\n  v_dummy          text;\r\n  spath            text;\r\n  spath_tmp        text;\r\n  -- issue#86 fix\r\n  isGenerated      text;\r\n  \r\n  -- issue#91 fix\r\n  tblowner         text;\r\n  func_owner       text;\r\n  func_name        text;\r\n  func_args        text;\r\n  func_argno       integer;\r\n  view_owner       text; \r\n\r\n  -- issue#92    \r\n  calleruser       text;\r\n  \r\n  -- issue#94\r\n  bData            boolean := False;\r\n  bDDLOnly         boolean := False;\r\n  bVerbose         boolean := False;\r\n  bDebug           boolean := False;\r\n  bNoACL           boolean := False;\r\n  bNoOwner         boolean := False;\r\n  arglen           integer;\r\n  vargs            text;\r\n  avarg            public.cloneparms;\r\n\r\n  -- issue#98\r\n  mvarray          text[] := '{}';  \r\n  mvscopied        integer := 0;\r\n  \r\n  -- issue#99 tablespaces\r\n  tblspace         text;\r\n  \r\n  -- issue#101\r\n  bFileCopy        boolean := False;\r\n  \r\n  t                timestamptz := clock_timestamp();\r\n  r                timestamptz;\r\n  s                timestamptz;\r\n  v_version        text := '1.17  May 17, 2023';\r\n\r\nBEGIN\r\n  -- Make sure NOTICE are shown\r\n  SET client_min_messages = 'notice';\r\n  RAISE NOTICE 'clone_schema version %', v_version;\r\n\r\n  IF 'DEBUG'   = ANY ($3) THEN bDebug = True; END IF;\r\n  IF 'VERBOSE' = ANY ($3) THEN bVerbose = True; END IF;\r\n  \r\n  -- IF bVerbose THEN RAISE NOTICE 'START: %',clock_timestamp() - t; END IF;\r\n  \r\n  arglen := array_length($3, 1);\r\n  IF arglen IS NULL THEN\r\n    -- nothing to do, so defaults are assumed\r\n    NULL;\r\n  ELSE\r\n    -- loop thru args\r\n    -- IF 'NO_TRIGGERS' = ANY ($3)\r\n    -- select array_to_string($3, ',', '***') INTO vargs;\r\n    IF bDebug THEN RAISE NOTICE 'DEBUG: arguments=%', $3; END IF;\r\n    FOREACH avarg IN ARRAY $3 LOOP\r\n      IF bDebug THEN RAISE NOTICE 'DEBUG: arg=%', avarg; END IF;\r\n      IF avarg = 'DATA' THEN\r\n        bData = True;\r\n      ELSEIF avarg = 'NODATA' THEN\r\n        -- already set to that by default\r\n        bData = False;\r\n      ELSEIF avarg = 'DDLONLY' THEN\r\n        bDDLOnly = True;\r\n      ELSEIF avarg = 'NOACL' THEN\r\n        bNoACL = True;\r\n      ELSEIF avarg = 'NOOWNER' THEN\r\n        bNoOwner = True;        \r\n      -- issue#101 fix\r\n      ELSEIF avarg = 'FILECOPY' THEN\r\n        bFileCopy = True;\r\n      END IF;\r\n    END LOOP;\r\n    IF bData and bDDLOnly THEN \r\n      RAISE WARNING 'You can only specify DDLONLY or DATA, but not both.';\r\n      RETURN;\r\n    END IF;\r\n  END IF;  \r\n  \r\n  -- Get server version info to handle certain things differently based on the version.\r\n  SELECT setting INTO sq_server_version\r\n  FROM pg_settings\r\n  WHERE name = 'server_version';\r\n  SELECT version() INTO sq_version;\r\n  \r\n  IF POSITION('compiled by Visual C++' IN sq_version) > 0 THEN\r\n      bWindows = True;\r\n      RAISE NOTICE 'Windows: %', sq_version;\r\n  ELSE\r\n      bWindows = False;\r\n      RAISE NOTICE 'Linux: %', sq_version;\r\n  END IF;\r\n  SELECT setting INTO sq_server_version_num\r\n  FROM pg_settings\r\n  WHERE name = 'server_version_num';\r\n\r\n  IF sq_server_version_num < 100000 THEN\r\n    RAISE WARNING 'Server Version:%  Number:%  PG Versions older than v10 are not supported.', sq_server_version, sq_server_version_num;\r\n    RETURN;\r\n  END IF;\r\n\r\n  -- Check that source_schema exists\r\n  SELECT oid INTO src_oid\r\n  FROM pg_namespace\r\n  WHERE nspname = quote_ident(source_schema);\r\n\r\n  IF NOT FOUND\r\n    THEN\r\n    RAISE NOTICE ' source schema % does not exist!', source_schema;\r\n    RETURN ;\r\n  END IF;\r\n\r\n  -- Check for case-sensitive target schemas and reject them for now.\r\n  SELECT lower(dest_schema) = dest_schema INTO abool;\r\n  IF not abool THEN\r\n      RAISE NOTICE 'Case-sensitive target schemas are not supported at this time.';\r\n      RETURN;\r\n  END IF;\r\n\r\n  -- Check that dest_schema does not yet exist\r\n  PERFORM nspname\r\n  FROM pg_namespace\r\n  WHERE nspname = quote_ident(dest_schema);\r\n\r\n  IF FOUND\r\n    THEN\r\n    RAISE NOTICE ' dest schema % already exists!', dest_schema;\r\n    RETURN ;\r\n  END IF;\r\n  IF bDDLOnly and bData THEN\r\n    RAISE WARNING 'You cannot specify to clone data and generate ddl at the same time.';\r\n    RETURN ;\r\n  END IF;\r\n\r\n  -- Issue#92\r\n  SELECT current_user into calleruser;\r\n  \r\n  -- Set the search_path to source schema. Before exiting set it back to what it was before.\r\n  -- In order to avoid issues with the special schema name \"$user\" that may be\r\n  -- returned unquoted by some applications, we ensure it remains double quoted.\r\n  -- MJV FIX: #47\r\n  SELECT setting INTO v_dummy FROM pg_settings WHERE name='search_path';\r\n  IF bDebug THEN RAISE NOTICE 'DEBUG: search_path=%', v_dummy; END IF;\r\n  \r\n  SELECT REPLACE(REPLACE(setting, '\"$user\"', '$user'), '$user', '\"$user\"') INTO src_path_old\r\n  FROM pg_settings WHERE name = 'search_path';\r\n\r\n  IF bDebug THEN RAISE NOTICE 'DEBUG: src_path_old=%', src_path_old; END IF;\r\n\r\n  EXECUTE 'SET search_path = ' || quote_ident(source_schema) ;\r\n  SELECT setting INTO src_path_new FROM pg_settings WHERE name='search_path';\r\n  IF bDebug THEN RAISE NOTICE 'DEBUG: new search_path=%', src_path_new; END IF;\r\n\r\n  -- Validate required types exist.  If not, create them.\r\n  SELECT a.objtypecnt, b.permtypecnt INTO cnt, cnt2\r\n  FROM (\r\n      SELECT count(*) AS objtypecnt\r\n      FROM pg_catalog.pg_type t\r\n      LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\r\n  WHERE (t.typrelid = 0\r\n      OR (\r\n          SELECT c.relkind = 'c'\r\n          FROM pg_catalog.pg_class c\r\n          WHERE c.oid = t.typrelid))\r\n      AND NOT EXISTS (\r\n          SELECT 1\r\n          FROM pg_catalog.pg_type el\r\n          WHERE el.oid = t.typelem\r\n              AND el.typarray = t.oid)\r\n          AND n.nspname <> 'pg_catalog'\r\n          AND n.nspname <> 'information_schema'\r\n          AND pg_catalog.pg_type_is_visible(t.oid)\r\n          AND pg_catalog.format_type(t.oid, NULL) = 'obj_type') a, (\r\n          SELECT count(*) AS permtypecnt\r\n          FROM pg_catalog.pg_type t\r\n          LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\r\n      WHERE (t.typrelid = 0\r\n          OR (\r\n              SELECT c.relkind = 'c'\r\n              FROM pg_catalog.pg_class c\r\n              WHERE c.oid = t.typrelid))\r\n          AND NOT EXISTS (\r\n              SELECT 1\r\n              FROM pg_catalog.pg_type el\r\n              WHERE el.oid = t.typelem\r\n                  AND el.typarray = t.oid)\r\n              AND n.nspname <> 'pg_catalog'\r\n              AND n.nspname <> 'information_schema'\r\n              AND pg_catalog.pg_type_is_visible(t.oid)\r\n              AND pg_catalog.format_type(t.oid, NULL) = 'perm_type') b;\r\n\r\n  IF cnt = 0 THEN\r\n    CREATE TYPE obj_type AS ENUM ('TABLE','VIEW','COLUMN','SEQUENCE','FUNCTION','SCHEMA','DATABASE');\r\n  END IF;\r\n  IF cnt2 = 0 THEN\r\n    CREATE TYPE perm_type AS ENUM ('SELECT','INSERT','UPDATE','DELETE','TRUNCATE','REFERENCES','TRIGGER','USAGE','CREATE','EXECUTE','CONNECT','TEMPORARY');\r\n  END IF;\r\n\r\n  -- Issue#95\r\n  SELECT quote_ident( pg_catalog.pg_get_userbyid(nspowner) ) INTO buffer FROM pg_namespace WHERE nspname = quote_ident(source_schema);\r\n\r\n  IF bDDLOnly THEN\r\n    RAISE NOTICE ' Only generating DDL, not actually creating anything...';\r\n    -- issue#95\r\n    IF bNoOwner THEN\r\n        RAISE INFO 'CREATE SCHEMA %;', quote_ident(dest_schema);    \r\n    ELSE\r\n        RAISE INFO 'CREATE SCHEMA % AUTHORIZATION %;', quote_ident(dest_schema), buffer;    \r\n    END IF;\r\n    RAISE NOTICE 'SET search_path=%;', quote_ident(dest_schema);\r\n  ELSE\r\n    -- issue#95\r\n    IF bNoOwner THEN\r\n        EXECUTE 'CREATE SCHEMA ' || quote_ident(dest_schema) ;\r\n    ELSE\r\n        EXECUTE 'CREATE SCHEMA ' || quote_ident(dest_schema) || ' AUTHORIZATION ' || buffer;\r\n    END IF;\r\n  END IF;\r\n\r\n  -- Do system table validations for subsequent system table queries\r\n  -- Issue#65 Fix\r\n  SELECT count(*) into cnt\r\n  FROM pg_attribute\r\n  WHERE  attrelid = 'pg_proc'::regclass AND attname = 'prokind';\r\n\r\n  IF cnt = 0 THEN\r\n      is_prokind = False;\r\n  ELSE\r\n      is_prokind = True;\r\n  END IF;\r\n\r\n  -- MV: Create Collations\r\n  action := 'Collations';\r\n  cnt := 0;\r\n  -- Issue#96 Handle differently based on PG Versions (PG15 rely on colliculocale, not collcolocate)\r\n  -- perhaps use this logic instead: COALESCE(c.collcollate, c.colliculocale) AS lc_collate, COALESCE(c.collctype, c.colliculocale) AS lc_type  \r\n  IF sq_server_version_num < 100000 THEN\r\n    RAISE NOTICE ' Collation cloning is are not supported in PG versions older than v10.  Current version is %-%', sq_server_version, sq_server_version_num;\r\n  ELSEIF sq_server_version_num > 150000 THEN \r\n    FOR arec IN\r\n      SELECT n.nspname AS schemaname, a.rolname AS ownername, c.collname, c.collprovider, c.collcollate AS locale, \r\n             'CREATE COLLATION ' || quote_ident(dest_schema) || '.\"' || c.collname || '\" (provider = ' || \r\n             CASE WHEN c.collprovider = 'i' THEN 'icu' WHEN c.collprovider = 'c' THEN 'libc' ELSE '' END || \r\n             ', locale = ''' || c.colliculocale || ''');' AS COLL_DDL\r\n      FROM pg_collation c\r\n          JOIN pg_namespace n ON (c.collnamespace = n.oid)\r\n          JOIN pg_roles a ON (c.collowner = a.oid)\r\n      WHERE n.nspname = quote_ident(source_schema)\r\n      ORDER BY c.collname\r\n    LOOP\r\n      BEGIN\r\n        cnt := cnt + 1;\r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%', arec.coll_ddl;\r\n        ELSE\r\n          EXECUTE arec.coll_ddl;\r\n        END IF;\r\n      END;\r\n    END LOOP;\r\n  ELSE\r\n    FOR arec IN\r\n      SELECT n.nspname AS schemaname, a.rolname AS ownername, c.collname, c.collprovider, c.collcollate AS locale, \r\n             'CREATE COLLATION ' || quote_ident(dest_schema) || '.\"' || c.collname || '\" (provider = ' || \r\n             CASE WHEN c.collprovider = 'i' THEN 'icu' WHEN c.collprovider = 'c' THEN 'libc' ELSE '' END || \r\n             ', locale = ''' || c.collcollate || ''');' AS COLL_DDL\r\n      FROM pg_collation c\r\n          JOIN pg_namespace n ON (c.collnamespace = n.oid)\r\n          JOIN pg_roles a ON (c.collowner = a.oid)\r\n      WHERE n.nspname = quote_ident(source_schema)\r\n      ORDER BY c.collname\r\n    LOOP\r\n      BEGIN\r\n        cnt := cnt + 1;\r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%', arec.coll_ddl;\r\n        ELSE\r\n          EXECUTE arec.coll_ddl;\r\n        END IF;\r\n      END;\r\n    END LOOP;\r\n  END IF;\r\n  RAISE NOTICE '  COLLATIONS cloned: %', LPAD(cnt::text, 5, ' ');\r\n\r\n  -- MV: Create Domains\r\n  action := 'Domains';\r\n  cnt := 0;\r\n  FOR arec IN\r\n    SELECT n.nspname AS \"Schema\", t.typname AS \"Name\", pg_catalog.format_type(t.typbasetype, t.typtypmod) AS \"Type\", (\r\n            SELECT c.collname\r\n            FROM pg_catalog.pg_collation c, pg_catalog.pg_type bt\r\n            WHERE c.oid = t.typcollation\r\n                AND bt.oid = t.typbasetype\r\n                AND t.typcollation <> bt.typcollation) AS \"Collation\", CASE WHEN t.typnotnull THEN\r\n            'not null'\r\n        END AS \"Nullable\", t.typdefault AS \"Default\", pg_catalog.array_to_string(ARRAY (\r\n                SELECT pg_catalog.pg_get_constraintdef(r.oid, TRUE)\r\n                FROM pg_catalog.pg_constraint r\r\n                -- Issue#78 FIX: handle case-sensitive names with quote_ident() on t.typename\r\n                WHERE t.oid = r.contypid), ' ') AS \"Check\", 'CREATE DOMAIN ' || quote_ident(dest_schema) || '.' || quote_ident(t.typname) || ' AS ' || pg_catalog.format_type(t.typbasetype, t.typtypmod) ||\r\n                CASE WHEN t.typnotnull IS NOT NULL THEN\r\n            ' NOT NULL '\r\n        ELSE\r\n            ' '\r\n        END || CASE WHEN t.typdefault IS NOT NULL THEN\r\n            'DEFAULT ' || t.typdefault || ' '\r\n        ELSE\r\n            ' '\r\n        END || pg_catalog.array_to_string(ARRAY (\r\n                SELECT pg_catalog.pg_get_constraintdef(r.oid, TRUE)\r\n                FROM pg_catalog.pg_constraint r\r\n                WHERE t.oid = r.contypid), ' ') || ';' AS DOM_DDL\r\n    FROM pg_catalog.pg_type t\r\n        LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\r\n    WHERE t.typtype = 'd'\r\n        AND n.nspname = quote_ident(source_schema)\r\n        AND pg_catalog.pg_type_is_visible(t.oid)\r\n    ORDER BY 1, 2\r\n  LOOP\r\n    BEGIN\r\n      cnt := cnt + 1;\r\n      IF bDDLOnly THEN\r\n        RAISE INFO '%', arec.dom_ddl;\r\n      ELSE\r\n        EXECUTE arec.dom_ddl;\r\n      END IF;\r\n    END;\r\n  END LOOP;\r\n  RAISE NOTICE '     DOMAINS cloned: %', LPAD(cnt::text, 5, ' ');\r\n\r\n  -- MV: Create types\r\n  action := 'Types';\r\n  cnt := 0;\r\n  FOR arec IN\r\n    SELECT c.relkind, n.nspname AS schemaname, t.typname AS typname, t.typcategory, pg_catalog.pg_get_userbyid(t.typowner) AS owner, CASE WHEN t.typcategory = 'C' THEN\r\n            'CREATE TYPE ' || quote_ident(dest_schema) || '.' || t.typname || ' AS (' || array_to_string(array_agg(a.attname || ' ' || pg_catalog.format_type(a.atttypid, a.atttypmod)\r\n                ORDER BY c.relname, a.attnum), ', ') || ');'\r\n        WHEN t.typcategory = 'E' THEN\r\n            'CREATE TYPE ' || quote_ident(dest_schema) || '.' || t.typname || ' AS ENUM (' || REPLACE(quote_literal(array_to_string(array_agg(e.enumlabel ORDER BY e.enumsortorder), ',')), ',', ''',''') || ');'\r\n        ELSE\r\n            ''\r\n        END AS type_ddl\r\n    FROM pg_type t\r\n        JOIN pg_namespace n ON (n.oid = t.typnamespace)\r\n        LEFT JOIN pg_enum e ON (t.oid = e.enumtypid)\r\n        LEFT JOIN pg_class c ON (c.reltype = t.oid)\r\n        LEFT JOIN pg_attribute a ON (a.attrelid = c.oid)\r\n    WHERE n.nspname = quote_ident(source_schema)\r\n        AND (c.relkind IS NULL\r\n            OR c.relkind = 'c')\r\n        AND t.typcategory IN ('C', 'E')\r\n    GROUP BY 1, 2, 3, 4, 5\r\n    ORDER BY n.nspname, t.typcategory, t.typname\r\n\r\n  LOOP\r\n    BEGIN\r\n      cnt := cnt + 1;\r\n      -- Keep composite and enum types in separate branches for fine tuning later if needed.\r\n      IF arec.typcategory = 'E' THEN\r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%', arec.type_ddl;\r\n          \r\n          --issue#95\r\n          IF NOT bNoOwner THEN\r\n            RAISE INFO 'ALTER TYPE % OWNER TO  %;', quote_ident(dest_schema) || '.' || arec.typname, quote_ident( arec.owner );\r\n          END IF;\r\n        ELSE\r\n          EXECUTE arec.type_ddl;\r\n\r\n          --issue#95\r\n          IF NOT bNoOwner THEN\r\n\t    EXECUTE 'ALTER TYPE ' || quote_ident(dest_schema) || '.' || arec.typname || ' OWNER TO ' || quote_ident( arec.owner );\r\n\t  END IF;\r\n\r\n        END IF;\r\n      ELSIF arec.typcategory = 'C' THEN\r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%', arec.type_ddl;\r\n          --issue#95\r\n          IF NOT bNoOwner THEN\r\n            RAISE INFO 'ALTER TYPE % OWNER TO  %;', quote_ident(dest_schema) || '.' || arec.typname, quote_ident( arec.owner );\r\n          END IF;\r\n          \r\n        ELSE\r\n          EXECUTE arec.type_ddl;\r\n          \r\n          --issue#95\r\n          IF NOT bNoOwner THEN\r\n\t    EXECUTE 'ALTER TYPE ' || quote_ident(dest_schema) || '.' || arec.typname || ' OWNER TO ' || quote_ident( arec.owner );\r\n\t  END IF;\r\n        END IF;\r\n      ELSE\r\n          RAISE NOTICE ' Unhandled type:%-%', arec.typcategory, arec.typname;\r\n      END IF;\r\n    END;\r\n  END LOOP;\r\n  RAISE NOTICE '       TYPES cloned: %', LPAD(cnt::text, 5, ' ');\r\n\r\n  -- Create sequences\r\n  action := 'Sequences';\r\n  cnt := 0;\r\n  -- fix#63  get from pg_sequences not information_schema\r\n  -- fix#63  take 2: get it from information_schema.sequences since we need to treat IDENTITY columns differently.\r\n  -- fix#95  get owner as well by joining to pg_sequences\r\n  FOR object, buffer IN\r\n    SELECT s1.sequence_name::text, quote_ident( s2.sequenceowner ) FROM information_schema.sequences s1 \r\n    JOIN pg_sequences s2 ON (s1.sequence_schema = s2.schemaname AND s1.sequence_name = s2.sequencename)\r\n    AND s1.sequence_schema = quote_ident(source_schema)\r\n  LOOP\r\n    cnt := cnt + 1;\r\n    IF bDDLOnly THEN\r\n      -- issue#95\r\n      RAISE INFO '%', 'CREATE SEQUENCE ' || quote_ident(dest_schema) || '.' || quote_ident(object) || ';';\r\n      IF NOT bNoOwner THEN    \r\n        RAISE INFO '%', 'ALTER  SEQUENCE ' || quote_ident(dest_schema) || '.' || quote_ident(object) || ' OWNER TO ' || buffer || ';';\r\n      END IF;\r\n    ELSE\r\n      EXECUTE 'CREATE SEQUENCE ' || quote_ident(dest_schema) || '.' || quote_ident(object);\r\n      -- issue#95\r\n      IF NOT bNoOwner THEN    \r\n        EXECUTE 'ALTER SEQUENCE '  || quote_ident(dest_schema) || '.' || quote_ident(object) || ' OWNER TO ' || buffer;\r\n      END IF;\r\n    END IF;\r\n    srctbl := quote_ident(source_schema) || '.' || quote_ident(object);\r\n\r\n    IF sq_server_version_num < 100000 THEN\r\n      EXECUTE 'SELECT last_value, is_called FROM ' || quote_ident(source_schema) || '.' || quote_ident(object) || ';' INTO sq_last_value, sq_is_called;\r\n      EXECUTE 'SELECT maximum_value, start_value, increment, minimum_value, 1 cache_size, cycle_option, data_type\r\n               FROM information_schema.sequences WHERE sequence_schema='|| quote_literal(source_schema) || ' AND sequence_name=' || quote_literal(object) || ';'\r\n               INTO sq_max_value, sq_start_value, sq_increment_by, sq_min_value, sq_cache_value, sq_is_cycled, sq_data_type;\r\n      IF sq_is_cycled\r\n        THEN\r\n          sq_cycled := 'CYCLE';\r\n      ELSE\r\n          sq_cycled := 'NO CYCLE';\r\n      END IF;\r\n\r\n      qry := 'ALTER SEQUENCE '   || quote_ident(dest_schema) || '.' || quote_ident(object)\r\n             || ' INCREMENT BY ' || sq_increment_by\r\n             || ' MINVALUE '     || sq_min_value\r\n             || ' MAXVALUE '     || sq_max_value\r\n             -- will update current sequence value after this\r\n             || ' START WITH '   || sq_start_value\r\n             || ' RESTART '      || sq_min_value\r\n             || ' CACHE '        || sq_cache_value\r\n             || ' '              || sq_cycled || ' ;' ;\r\n    ELSE\r\n      EXECUTE 'SELECT max_value, start_value, increment_by, min_value, cache_size, cycle, data_type, COALESCE(last_value, 1)\r\n            FROM pg_catalog.pg_sequences WHERE schemaname='|| quote_literal(source_schema) || ' AND sequencename=' || quote_literal(object) || ';'\r\n            INTO sq_max_value, sq_start_value, sq_increment_by, sq_min_value, sq_cache_value, sq_is_cycled, sq_data_type, sq_last_value;\r\n      IF sq_is_cycled\r\n        THEN\r\n          sq_cycled := 'CYCLE';\r\n      ELSE\r\n          sq_cycled := 'NO CYCLE';\r\n      END IF;\r\n\r\n      qry := 'ALTER SEQUENCE '   || quote_ident(dest_schema) || '.' || quote_ident(object)\r\n             || ' AS ' || sq_data_type\r\n             || ' INCREMENT BY ' || sq_increment_by\r\n             || ' MINVALUE '     || sq_min_value\r\n             || ' MAXVALUE '     || sq_max_value\r\n             -- will update current sequence value after this\r\n             || ' START WITH '   || sq_start_value\r\n             || ' RESTART '      || sq_min_value\r\n             || ' CACHE '        || sq_cache_value\r\n             || ' '              || sq_cycled || ' ;' ;\r\n    END IF;\r\n\r\n    IF bDDLOnly THEN\r\n      RAISE INFO '%', qry;\r\n    ELSE\r\n      EXECUTE qry;\r\n    END IF;\r\n\r\n    buffer := quote_ident(dest_schema) || '.' || quote_ident(object);\r\n    IF bData THEN\r\n      EXECUTE 'SELECT setval( ''' || buffer || ''', ' || sq_last_value || ', ' || sq_is_called || ');' ;\r\n    ELSE\r\n      if bDDLOnly THEN\r\n        -- fix#63\r\n        --  RAISE INFO '%', 'SELECT setval( ''' || buffer || ''', ' || sq_start_value || ', ' || sq_is_called || ');' ;\r\n        RAISE INFO '%', 'SELECT setval( ''' || buffer || ''', ' || sq_last_value || ', ' || sq_is_called || ');' ;\r\n      ELSE\r\n        -- fix#63\r\n        -- EXECUTE 'SELECT setval( ''' || buffer || ''', ' || sq_start_value || ', ' || sq_is_called || ');' ;\r\n        EXECUTE 'SELECT setval( ''' || buffer || ''', ' || sq_last_value || ', ' || sq_is_called || ');' ;\r\n      END IF;\r\n\r\n    END IF;\r\n  END LOOP;\r\n  RAISE NOTICE '   SEQUENCES cloned: %', LPAD(cnt::text, 5, ' ');\r\n\r\n\r\n  -- Create tables including partitioned ones (parent/children) and unlogged ones.  Order by is critical since child partition range logic is dependent on it.\r\n  action := 'Tables';\r\n  SELECT setting INTO v_dummy FROM pg_settings WHERE name='search_path';\r\n  IF bDebug THEN RAISE NOTICE 'DEBUG: search_path=%', v_dummy; END IF;\r\n  \r\n  cnt := 0;\r\n  -- Issue#61 FIX: use set_config for empty string\r\n  -- SET search_path = '';\r\n  SELECT set_config('search_path', '', false) into v_dummy;\r\n  IF bDebug THEN RAISE NOTICE 'DEBUG: setting search_path to empty string:%', v_dummy; END IF;\r\n  -- Fix#86 add isgenerated to column list\r\n  -- Fix#91 add tblowner for setting the table ownership to that of the source\r\n  -- Fix#99 added join to pg_tablespace\r\n  FOR tblname, relpersist, bRelispart, relknd, data_type, udt_name, ocomment, l_child, isGenerated, tblowner, tblspace  IN\r\n    -- 2021-03-08 MJV #39 fix: change sql to get indicator of user-defined columns to issue warnings\r\n    -- select c.relname, c.relpersistence, c.relispartition, c.relkind\r\n    -- FROM pg_class c, pg_namespace n where n.oid = c.relnamespace and n.nspname = quote_ident(source_schema) and c.relkind in ('r','p') and\r\n    -- order by c.relkind desc, c.relname\r\n    --Fix#65 add another left join to distinguish child tables by inheritance\r\n    -- Fix#86 add is_generated to column select\r\n    -- Fix#91 add tblowner to the select\r\n    SELECT DISTINCT c.relname, c.relpersistence, c.relispartition, c.relkind, co.data_type, co.udt_name, obj_description(c.oid), i.inhrelid, COALESCE(co.is_generated, ''), \r\n                    quote_ident( pg_catalog.pg_get_userbyid(c.relowner) ) as \"Owner\", CASE WHEN reltablespace = 0 THEN 'pg_default' ELSE ts.spcname END as tablespace\r\n    FROM pg_class c\r\n        JOIN pg_namespace n ON (n.oid = c.relnamespace\r\n                AND n.nspname = quote_ident(source_schema)\r\n                AND c.relkind IN ('r', 'p'))\r\n        LEFT JOIN information_schema.columns co ON (co.table_schema = n.nspname\r\n                AND co.table_name = c.relname\r\n                -- AND co.data_type = 'USER-DEFINED')\r\n                AND (co.data_type = 'USER-DEFINED' OR co.is_generated = 'ALWAYS'))\r\n        LEFT JOIN pg_inherits i ON (c.oid = i.inhrelid) \r\n        -- issue#99 added join\r\n        LEFT JOIN pg_tablespace ts ON (c.reltablespace = ts.oid) \r\n    ORDER BY c.relkind DESC, c.relname\r\n  LOOP\r\n    cnt := cnt + 1;\r\n    IF l_child IS NULL THEN\r\n      bChild := False;\r\n    ELSE\r\n      bChild := True;\r\n    END IF;\r\n    IF bDebug THEN RAISE NOTICE 'DEBUG: TABLE START --> table=%  bRelispart=%  relkind=%  bChild=%',tblname, bRelispart, relknd, bChild; END IF;\r\n\r\n    IF data_type = 'USER-DEFINED' THEN\r\n      -- RAISE NOTICE ' Table (%) has column(s) with user-defined types so using get_table_ddl() instead of CREATE TABLE LIKE construct.',tblname;\r\n      cnt :=cnt;\r\n    END IF;\r\n    buffer := quote_ident(dest_schema) || '.' || quote_ident(tblname);\r\n    buffer2 := '';\r\n    IF relpersist = 'u' THEN\r\n      buffer2 := 'UNLOGGED ';\r\n    END IF;\r\n    IF relknd = 'r' THEN\r\n      IF bDDLOnly THEN\r\n        IF data_type = 'USER-DEFINED' THEN\r\n          -- FIXED #65, #67\r\n          -- SELECT * INTO buffer3 FROM public.pg_get_tabledef(quote_ident(source_schema), tblname);\r\n          SELECT * INTO buffer3 FROM public.get_table_ddl(quote_ident(source_schema), tblname, False);\r\n\r\n          buffer3 := REPLACE(buffer3, quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.');\r\n          RAISE INFO '%', buffer3;\r\n          -- issue#91 fix\r\n          -- issue#95\r\n          IF NOT bNoOwner THEN    \r\n            RAISE INFO 'ALTER TABLE IF EXISTS % OWNER TO %;', quote_ident(dest_schema) || '.' || tblname, tblowner;          \r\n          END IF;\r\n        ELSE\r\n          IF NOT bChild THEN\r\n            RAISE INFO '%', 'CREATE ' || buffer2 || 'TABLE ' || buffer || ' (LIKE ' || quote_ident(source_schema) || '.' || quote_ident(tblname) || ' INCLUDING ALL);';\r\n            -- issue#91 fix\r\n             -- issue#95\r\n            IF NOT bNoOwner THEN    \r\n              RAISE INFO 'ALTER TABLE IF EXISTS % OWNER TO %;', quote_ident(dest_schema) || '.' || tblname, tblowner;\r\n            END IF;\r\n            \r\n            -- issue#99 \r\n            IF tblspace <> 'pg_default' THEN\r\n              -- replace with user-defined tablespace\r\n              -- ALTER TABLE myschema.mytable SET TABLESPACE usrtblspc;\r\n              RAISE INFO 'ALTER TABLE IF EXISTS % SET TABLESPACE %;', quote_ident(dest_schema) || '.' || tblname, tblspace;          \r\n            END IF;\r\n          ELSE\r\n            -- FIXED #65, #67\r\n            -- SELECT * INTO buffer3 FROM public.pg_get_tabledef(quote_ident(source_schema), tblname);\r\n            SELECT * INTO buffer3 FROM public.get_table_ddl(quote_ident(source_schema), tblname, False);\r\n            buffer3 := REPLACE(buffer3, quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.');\r\n            RAISE INFO '%', buffer3;\r\n            -- issue#91 fix\r\n            -- issue#95\r\n            IF NOT bNoOwner THEN    \r\n              RAISE INFO 'ALTER TABLE IF EXISTS % OWNER TO %;', quote_ident(dest_schema) || '.' || tblname, tblowner;\r\n            END IF;\r\n          END IF;\r\n        END IF;\r\n      ELSE\r\n        IF data_type = 'USER-DEFINED' THEN\r\n          -- FIXED #65, #67\r\n          -- SELECT * INTO buffer3 FROM public.pg_get_tabledef(quote_ident(source_schema), tblname);\r\n          SELECT * INTO buffer3 FROM public.get_table_ddl(quote_ident(source_schema), tblname, False);\r\n          buffer3 := REPLACE(buffer3, quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.');\r\n          IF bDebug THEN RAISE NOTICE 'DEBUG: tabledef01:%', buffer3; END IF;\r\n          -- #82: Table def should be fully qualified with target schema, \r\n          --      so just make search path = public to handle extension types that should reside in public schema\r\n          v_dummy = 'public';\r\n          SELECT set_config('search_path', v_dummy, false) into v_dummy;\r\n          EXECUTE buffer3;\r\n          -- issue#91 fix\r\n          -- issue#95\r\n          IF NOT bNoOwner THEN    \r\n            buffer3 = 'ALTER TABLE IF EXISTS ' || quote_ident(dest_schema) || '.' || tblname || ' OWNER TO ' || tblowner;\r\n            EXECUTE buffer3;\r\n          END IF;\r\n        ELSE\r\n          IF (NOT bChild OR bRelispart) THEN\r\n            buffer3 := 'CREATE ' || buffer2 || 'TABLE ' || buffer || ' (LIKE ' || quote_ident(source_schema) || '.' || quote_ident(tblname) || ' INCLUDING ALL)';\r\n            IF bDebug THEN RAISE NOTICE 'DEBUG: tabledef02:%', buffer3; END IF;\r\n            EXECUTE buffer3;\r\n            -- issue#91 fix\r\n            -- issue#95\r\n            IF NOT bNoOwner THEN    \r\n              buffer3 = 'ALTER TABLE IF EXISTS ' || quote_ident(dest_schema) || '.'  || quote_ident(tblname) || ' OWNER TO ' || tblowner;            \r\n              EXECUTE buffer3;              \r\n            END IF;\r\n            \r\n            -- issue#99\r\n            IF tblspace <> 'pg_default' THEN\r\n              -- replace with user-defined tablespace\r\n              -- ALTER TABLE myschema.mytable SET TABLESPACE usrtblspc;\r\n              buffer3 = 'ALTER TABLE IF EXISTS ' || quote_ident(dest_schema) || '.' || tblname || ' SET TABLESPACE ' || tblspace;\r\n              EXECUTE buffer3;\r\n            END IF;\r\n\r\n          ELSE\r\n            -- FIXED #65, #67\r\n            -- SELECT * INTO buffer3 FROM public.pg_get_tabledef(quote_ident(source_schema), tblname);\r\n            SELECT * INTO buffer3 FROM public.get_table_ddl(quote_ident(source_schema), tblname, False);\r\n\r\n            buffer3 := REPLACE(buffer3, quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.');\r\n            -- set client_min_messages higher to avoid messages like this:\r\n            -- NOTICE:  merging column \"city_id\" with inherited definition\r\n            set client_min_messages = 'WARNING';\r\n            IF bDebug THEN RAISE NOTICE 'DEBUG: tabledef03:%', buffer3; END IF;\r\n            EXECUTE buffer3;\r\n            -- issue#91 fix\r\n            -- issue#95\r\n            IF NOT bNoOwner THEN                \r\n              buffer3 = 'ALTER TABLE IF EXISTS ' || quote_ident(dest_schema) || '.' || tblname || ' OWNER TO ' || tblowner;\r\n              EXECUTE buffer3;\r\n            END IF;\r\n\r\n            -- reset it back, only get these for inheritance-based tables\r\n            set client_min_messages = 'notice';\r\n          END IF;\r\n        END IF;\r\n        -- Add table comment.\r\n        IF ocomment IS NOT NULL THEN\r\n          EXECUTE 'COMMENT ON TABLE ' || buffer || ' IS ' || quote_literal(ocomment);\r\n        END IF;\r\n      END IF;\r\n    ELSIF relknd = 'p' THEN\r\n      -- define parent table and assume child tables have already been created based on top level sort order.\r\n      -- Issue #103 Put the complex query into its own function, get_table_ddl_complex()\r\n      SELECT * INTO qry FROM public.get_table_ddl_complex(source_schema, dest_schema, tblname, sq_server_version_num);\r\n      IF bDebug THEN RAISE NOTICE 'DEBUG: tabledef04 - %', buffer; END IF;\r\n      \r\n      -- consider replacing complicated query above with this simple call to get_table_ddl()...\r\n      -- SELECT * INTO qry FROM public.get_table_ddl(quote_ident(source_schema), tblname, False);\r\n      -- qry := REPLACE(qry, quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.');\r\n\r\n      IF bDDLOnly THEN\r\n        RAISE INFO '%', qry;\r\n        -- issue#95\r\n        IF NOT bNoOwner THEN                \r\n            RAISE INFO 'ALTER TABLE IF EXISTS % OWNER TO %;', quote_ident(dest_schema) || '.' || quote_ident(tblname), tblowner;\r\n        END IF;\r\n      ELSE\r\n        -- Issue#103: we need to always set search_path priority to target schema when we execute DDL\r\n        IF bDebug THEN RAISE NOTICE 'DEBUG: tabledef04 context: old search path=%  new search path=% current search path=%', src_path_old, src_path_new, v_dummy; END IF;\r\n        SELECT setting INTO spath_tmp FROM pg_settings WHERE name = 'search_path';   \r\n        IF spath_tmp <> dest_schema THEN\r\n          -- change it to target schema and don't forget to change it back after we execute the DDL\r\n          spath = 'SET search_path = \"' || dest_schema || '\"';\r\n          IF bDebug THEN RAISE NOTICE 'DEBUG: changing search_path --> %', spath; END IF;\r\n          EXECUTE spath;\r\n          SELECT setting INTO v_dummy FROM pg_settings WHERE name = 'search_path';   \r\n          IF bDebug THEN RAISE NOTICE 'DEBUG: search_path changed to %', v_dummy; END IF;\r\n        END IF;\r\n        IF bDebug THEN RAISE NOTICE 'DEBUG: tabledef04:%', qry; END IF;\r\n        EXECUTE qry;\r\n        \r\n        -- Issue#103\r\n        -- Set search path back to what it was\r\n        spath = 'SET search_path = \"' || spath_tmp || '\"';\r\n        EXECUTE spath;\r\n        SELECT setting INTO v_dummy FROM pg_settings WHERE name = 'search_path';   \r\n        IF bDebug THEN RAISE NOTICE 'DEBUG: search_path changed back to %', v_dummy; END IF;\r\n        \r\n        -- issue#91 fix\r\n        -- issue#95\r\n        IF NOT bNoOwner THEN                \r\n          buffer3 = 'ALTER TABLE IF EXISTS ' || quote_ident(dest_schema) || '.' || quote_ident(tblname) || ' OWNER TO ' || tblowner;\r\n          EXECUTE buffer3;\r\n        END IF;\r\n        \r\n      END IF;\r\n      -- loop for child tables and alter them to attach to parent for specific partition method.\r\n      -- Issue#103 fix: only loop for the table we are currently processing, tblname!\r\n      FOR aname, part_range, object IN\r\n        SELECT quote_ident(dest_schema) || '.' || c1.relname as tablename, pg_catalog.pg_get_expr(c1.relpartbound, c1.oid) as partrange, quote_ident(dest_schema) || '.' || c2.relname as object\r\n        FROM pg_catalog.pg_class c1, pg_namespace n, pg_catalog.pg_inherits i, pg_class c2\r\n        WHERE n.nspname = quote_ident(source_schema) AND c1.relnamespace = n.oid AND c1.relkind = 'r' \r\n        -- Issue#103: added this condition to only work on current partitioned table.  The problem was regression testing previously only worked on one partition table clone case\r\n        AND c2.relname = tblname AND \r\n        c1.relispartition AND c1.oid=i.inhrelid AND i.inhparent = c2.oid AND c2.relnamespace = n.oid ORDER BY pg_catalog.pg_get_expr(c1.relpartbound, c1.oid) = 'DEFAULT',\r\n        c1.oid::pg_catalog.regclass::pg_catalog.text\r\n      LOOP\r\n        qry := 'ALTER TABLE ONLY ' || object || ' ATTACH PARTITION ' || aname || ' ' || part_range || ';';\r\n        IF bDebug THEN RAISE NOTICE 'DEBUG: %',qry; END IF;\r\n        -- issue#91, not sure if we need to do this for child tables\r\n        -- issue#95 we dont set ownership here\r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%', qry;\r\n          IF NOT bNoOwner THEN\r\n            NULL;\r\n          END IF;\r\n        ELSE\r\n          EXECUTE qry;\r\n          IF NOT bNoOwner THEN                \r\n            NULL;\r\n          END IF;\r\n        END IF;\r\n      END LOOP;\r\n    END IF;\r\n    -- INCLUDING ALL creates new index names, we restore them to the old name.\r\n    -- There should be no conflicts since they live in different schemas\r\n    FOR ix_old_name, ix_new_name IN\r\n      SELECT old.indexname, new.indexname\r\n      FROM pg_indexes old, pg_indexes new\r\n      WHERE old.schemaname = source_schema\r\n        AND new.schemaname = dest_schema\r\n        AND old.tablename = new.tablename\r\n        AND old.tablename = tblname\r\n        AND old.indexname <> new.indexname\r\n        AND regexp_replace(old.indexdef, E'.*USING','') = regexp_replace(new.indexdef, E'.*USING','')\r\n        ORDER BY old.indexdef, new.indexdef\r\n    LOOP\r\n      IF bDDLOnly THEN\r\n        RAISE INFO '%', 'ALTER INDEX ' || quote_ident(dest_schema) || '.'  || quote_ident(ix_new_name) || ' RENAME TO ' || quote_ident(ix_old_name) || ';';\r\n      ELSE\r\n        -- The SELECT query above may return duplicate names when a column is\r\n        -- indexed twice the same manner with 2 different names. Therefore, to\r\n        -- avoid a 'relation \"xxx\" already exists' we test if the index name\r\n        -- is in use or free. Skipping existing index will fallback on unused\r\n        -- ones and every duplicate will be mapped to distinct old names.\r\n        IF NOT EXISTS (\r\n            SELECT TRUE\r\n            FROM pg_indexes\r\n            WHERE schemaname = dest_schema\r\n              AND tablename = tblname\r\n              AND indexname = quote_ident(ix_old_name))\r\n          AND EXISTS (\r\n            SELECT TRUE\r\n            FROM pg_indexes\r\n            WHERE schemaname = dest_schema\r\n              AND tablename = tblname\r\n              AND indexname = quote_ident(ix_new_name))\r\n          THEN\r\n          EXECUTE 'ALTER INDEX ' || quote_ident(dest_schema) || '.' || quote_ident(ix_new_name) || ' RENAME TO ' || quote_ident(ix_old_name) || ';';\r\n        END IF;\r\n      END IF;\r\n    END LOOP;\r\n\r\n    IF bData THEN\r\n      -- Insert records from source table\r\n\r\n      -- 2021-03-03  MJV FIX\r\n      buffer := dest_schema || '.' || quote_ident(tblname);\r\n\r\n      -- 2020/06/18 - Issue #31 fix: add \"OVERRIDING SYSTEM VALUE\" for IDENTITY columns marked as GENERATED ALWAYS.\r\n      select count(*) into cnt2 from pg_class c, pg_attribute a, pg_namespace n\r\n          where a.attrelid = c.oid and c.relname = quote_ident(tblname) and n.oid = c.relnamespace and n.nspname = quote_ident(source_schema) and a.attidentity = 'a';\r\n      buffer3 := '';\r\n      IF cnt2 > 0 THEN\r\n          buffer3 := ' OVERRIDING SYSTEM VALUE';\r\n      END IF;\r\n      -- BUG for inserting rows from tables with user-defined columns\r\n      -- INSERT INTO sample_clone.address OVERRIDING SYSTEM VALUE SELECT * FROM sample.address;\r\n      -- ERROR:  column \"id2\" is of type sample_clone.udt_myint but expression is of type udt_myint\r\n      \r\n      -- Issue#86 fix:\r\n      -- IF data_type = 'USER-DEFINED' THEN\r\n      IF bDebug THEN RAISE NOTICE 'DEBUG: includerecs branch  table=%  data_type=%  isgenerated=%', tblname, data_type, isGenerated; END IF;\r\n      IF data_type = 'USER-DEFINED' OR isGenerated = 'ALWAYS' THEN\r\n\r\n        -- RAISE WARNING 'Bypassing copying rows for table (%) with user-defined data types.  You must copy them manually.', tblname;\r\n        -- wont work --> INSERT INTO clone1.address (id2, id3, addr) SELECT cast(id2 as clone1.udt_myint), cast(id3 as clone1.udt_myint), addr FROM sample.address;\r\n        -- Issue#101 --> INSERT INTO clone1.address2 (id2, id3, addr) SELECT id2::text::clone1.udt_myint, id3::text::clone1.udt_myint, addr FROM sample.address; \r\n\r\n        -- Issue#79 implementation follows        \r\n        -- COPY sample.statuses(id, s) TO '/tmp/statuses.txt' WITH DELIMITER AS ',';\r\n        -- COPY sample_clone1.statuses FROM '/tmp/statuses.txt' (DELIMITER ',', NULL '');\r\n        -- Issue#101 fix: use text cast to get around the problem.\r\n        IF bFileCopy THEN\r\n          IF bWindows THEN\r\n              buffer2   := 'COPY ' || quote_ident(source_schema) || '.' || quote_ident(tblname) || ' TO  ''C:\\WINDOWS\\TEMP\\cloneschema.tmp'' WITH DELIMITER AS '','';';\r\n              tblarray2 := tblarray2 || buffer2;\r\n              -- Issue #81 reformat COPY command for upload\r\n              -- buffer2:= 'COPY ' || quote_ident(dest_schema) || '.' || quote_ident(tblname) || '  FROM  ''C:\\WINDOWS\\TEMP\\cloneschema.tmp'' (DELIMITER '','', NULL '''');';\r\n              buffer2   := 'COPY ' || quote_ident(dest_schema) || '.' || quote_ident(tblname) || '  FROM  ''C:\\WINDOWS\\TEMP\\cloneschema.tmp'' (DELIMITER '','', NULL ''\\N'', FORMAT CSV);';\r\n              tblarray2 := tblarray2 || buffer2;\r\n          ELSE\r\n              buffer2   := 'COPY ' || quote_ident(source_schema) || '.' || quote_ident(tblname) || ' TO ''/tmp/cloneschema.tmp'' WITH DELIMITER AS '','';';\r\n              tblarray2 := tblarray2 || buffer2;\r\n              -- Issue #81 reformat COPY command for upload\r\n              -- buffer2   := 'COPY ' || quote_ident(dest_schema) || '.' || quote_ident(tblname) || '  FROM ''/tmp/cloneschema.tmp'' (DELIMITER '','', NULL '''');';\r\n              -- works--> COPY sample.timestamptbl2  FROM '/tmp/cloneschema.tmp' WITH (DELIMITER ',', NULL '\\N', FORMAT CSV) ;\r\n              buffer2   := 'COPY ' || quote_ident(dest_schema) || '.' || quote_ident(tblname) || '  FROM ''/tmp/cloneschema.tmp'' (DELIMITER '','', NULL ''\\N'', FORMAT CSV);';\r\n              tblarray2 := tblarray2 || buffer2;\r\n          END IF;\r\n        ELSE\r\n          -- Issue#101: assume direct copy with text cast, add to separate array\r\n          SELECT * INTO buffer3 FROM public.get_insert_stmt_ddl(quote_ident(source_schema), quote_ident(dest_schema), quote_ident(tblname), True);\r\n          tblarray3 := tblarray3 || buffer3;\r\n        END IF;\r\n      ELSE\r\n        -- bypass child tables since we populate them when we populate the parents\r\n        -- RAISE NOTICE 'tblname=%  bRelispart=%  relknd=%  l_child=%  bChild=%', tblname, bRelispart, relknd, l_child, bChild;\r\n        IF NOT bRelispart AND NOT bChild THEN\r\n          -- Issue#75: Must defer population of tables until child tables have been added to parents\r\n          -- Issue#101 Offer alternative of copy to/from file. Although originally intended for tables with UDTs, it is now expanded to handle all cases for performance improvement perhaps for large tables.\r\n          buffer2 := 'INSERT INTO ' || buffer || buffer3 || ' SELECT * FROM ' || quote_ident(source_schema) || '.' || quote_ident(tblname) || ';';\r\n          IF bFileCopy THEN\r\n            tblarray2:= tblarray2 || buffer2;\r\n          ELSE\r\n            tblarray := tblarray || buffer2;\r\n          END IF;\r\n        END IF;\r\n      END IF;\r\n    END IF;\r\n\r\n    -- Issue#61 FIX: use set_config for empty string\r\n    -- SET search_path = '';\r\n    SELECT set_config('search_path', '', false) into v_dummy;\r\n\r\n    FOR column_, default_ IN\r\n      SELECT column_name::text,\r\n             REPLACE(column_default::text, quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.')\r\n      FROM information_schema.COLUMNS\r\n      WHERE table_schema = source_schema\r\n          AND TABLE_NAME = tblname\r\n          AND column_default LIKE 'nextval(%' || quote_ident(source_schema) || '%::regclass)'\r\n    LOOP\r\n      -- Issue#78 FIX: handle case-sensitive names with quote_ident() on column name\r\n      buffer2 = 'ALTER TABLE ' || buffer || ' ALTER COLUMN ' || quote_ident(column_) || ' SET DEFAULT ' || default_ || ';';\r\n      IF bDDLOnly THEN\r\n        -- May need to come back and revisit this since previous sql will not return anything since no schema as created!\r\n        RAISE INFO '%', buffer2;\r\n      ELSE\r\n        EXECUTE buffer2;\r\n      END IF;\r\n    END LOOP;\r\n    \r\n    EXECUTE 'SET search_path = ' || quote_ident(source_schema) ;\r\n  END LOOP;\r\n  RAISE NOTICE '      TABLES cloned: %', LPAD(cnt::text, 5, ' ');\r\n\r\n  SELECT setting INTO v_dummy FROM pg_settings WHERE name = 'search_path';\r\n  IF bDebug THEN RAISE NOTICE 'DEBUG: search_path=%', v_dummy; END IF;\r\n\r\n  -- Assigning sequences to table columns.\r\n  action := 'Sequences assigning';\r\n  cnt := 0;\r\n  FOR object IN\r\n    SELECT sequence_name::text\r\n    FROM information_schema.sequences\r\n    WHERE sequence_schema = quote_ident(source_schema)\r\n  LOOP\r\n    cnt := cnt + 1;\r\n    srctbl := quote_ident(source_schema) || '.' || quote_ident(object);\r\n\r\n    -- Get owning column, inspired from Sadique Ali post at:\r\n    -- https://sadique.io/blog/2019/05/07/viewing-sequence-ownership-information-in-postgres/\r\n    SELECT ' OWNED BY '\r\n      || quote_ident(dest_schema)\r\n      || '.'\r\n      || quote_ident(dc.relname)\r\n      || '.'\r\n      || quote_ident(a.attname)\r\n    INTO sq_owned\r\n    FROM pg_class AS c\r\n      JOIN pg_depend AS d ON (c.relfilenode = d.objid)\r\n      JOIN pg_class AS dc ON (d.refobjid = dc.relfilenode)\r\n      JOIN pg_attribute AS a ON (\r\n        a.attnum = d.refobjsubid\r\n        AND a.attrelid = d.refobjid\r\n      )\r\n      JOIN pg_namespace n ON c.relnamespace = n.oid\r\n    WHERE n.nspname = quote_ident(source_schema)\r\n      AND c.relkind = 'S'\r\n      AND c.relname = object;\r\n\r\n    IF sq_owned IS NOT NULL THEN\r\n      qry := 'ALTER SEQUENCE '\r\n        || quote_ident(dest_schema)\r\n        || '.'\r\n        || quote_ident(object)\r\n        || sq_owned\r\n        || ';';\r\n\r\n      IF bDDLOnly THEN\r\n        RAISE INFO '%', qry;\r\n      ELSE\r\n        EXECUTE qry;\r\n      END IF;\r\n\r\n    END IF;\r\n\r\n  END LOOP;\r\n  RAISE NOTICE '    SEQUENCES set:      %', LPAD(cnt::text, 2, ' ');\r\n\r\n  -- Update IDENTITY sequences to the last value\r\n  action := 'Identity updating';\r\n  cnt := 0;\r\n  FOR object, sq_last_value IN\r\n    SELECT sequencename::text, COALESCE(last_value, -999) from pg_sequences where schemaname = quote_ident(source_schema)\r\n    AND NOT EXISTS\r\n    (select 1 from information_schema.sequences where sequence_schema = quote_ident(source_schema) and sequence_name = sequencename)\r\n  LOOP\r\n    IF sq_last_value = -999 THEN\r\n      continue;\r\n    END IF;\r\n    cnt := cnt + 1;\r\n    buffer := quote_ident(dest_schema) || '.' || quote_ident(object);\r\n    IF bData THEN\r\n      EXECUTE 'SELECT setval( ''' || buffer || ''', ' || sq_last_value || ', ' || sq_is_called || ');' ;\r\n    ELSE\r\n      if bDDLOnly THEN\r\n        -- fix#63\r\n        RAISE INFO '%', 'SELECT setval( ''' || buffer || ''', ' || sq_last_value || ', ' || sq_is_called || ');' ;\r\n      ELSE\r\n        -- fix#63\r\n        EXECUTE 'SELECT setval( ''' || buffer || ''', ' || sq_last_value || ', ' || sq_is_called || ');' ;\r\n      END IF;\r\n    END IF;\r\n  END LOOP;\r\n  RAISE NOTICE '   IDENTITIES set:      %', LPAD(cnt::text, 2, ' ');\r\n\r\n\r\n\r\n  -- Issue#78 forces us to defer FKeys until the end since we previously did row copies before FKeys\r\n  --  add FK constraint\r\n  -- action := 'FK Constraints';\r\n\r\n  -- Issue#62: Add comments on indexes, and then removed them from here and reworked later below.\r\n\r\n  -- Issue 90: moved functions to here, before views or MVs that might use them\r\n  -- Create functions\r\n    action := 'Functions';\r\n    cnt := 0;\r\n    -- MJV FIX per issue# 34\r\n    -- SET search_path = '';\r\n    EXECUTE 'SET search_path = ' || quote_ident(source_schema) ;\r\n    \r\n    -- Fixed Issue#65\r\n    -- Fixed Issue#97\r\n    -- FOR func_oid IN SELECT oid FROM pg_proc WHERE pronamespace = src_oid AND prokind != 'a'\r\n    IF is_prokind THEN\r\n      FOR func_oid, func_owner, func_name, func_args, func_argno, buffer3 IN \r\n          SELECT p.oid, quote_ident( pg_catalog.pg_get_userbyid(p.proowner) ), p.proname, oidvectortypes(p.proargtypes), p.pronargs,\r\n          CASE WHEN prokind = 'p' THEN 'PROCEDURE' WHEN prokind = 'f' THEN 'FUNCTION' ELSE '' END \r\n          FROM pg_proc p WHERE p.pronamespace = src_oid AND p.prokind != 'a'\r\n      LOOP\r\n        cnt := cnt + 1;\r\n        SELECT pg_get_functiondef(func_oid)\r\n        INTO qry;\r\n  \r\n        SELECT replace(qry, quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.') INTO dest_qry;\r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%;', dest_qry;\r\n          -- Issue#91 Fix\r\n          -- issue#95 \r\n          IF NOT bNoOwner THEN\r\n            IF func_argno = 0 THEN\r\n                RAISE INFO 'ALTER % %() OWNER TO %', buffer3, quote_ident(dest_schema) || '.' || quote_ident(func_name), func_owner || ';';\r\n            ELSE\r\n                RAISE INFO 'ALTER % % OWNER TO %', buffer3, quote_ident(dest_schema) || '.' || quote_ident(func_name) || '(' || func_args || ')', func_owner || ';';\r\n            END IF;\r\n          END IF;\r\n        ELSE\r\n          IF bDebug THEN RAISE NOTICE 'DEBUG: %', dest_qry; END IF;\r\n          EXECUTE dest_qry;\r\n\r\n          -- Issue#91 Fix\r\n          -- issue#95 \r\n          IF NOT bNoOwner THEN\r\n            IF func_argno = 0 THEN\r\n                dest_qry = 'ALTER ' || buffer3 || ' ' || quote_ident(dest_schema) || '.' || quote_ident(func_name) || '() OWNER TO ' || func_owner || ';';\r\n            ELSE\r\n                dest_qry = 'ALTER ' || buffer3 || ' ' || quote_ident(dest_schema) || '.' || quote_ident(func_name) || '(' || func_args || ') OWNER TO ' || func_owner || ';';\r\n            END IF;\r\n          END IF;\r\n          EXECUTE dest_qry;\r\n        END IF;\r\n      END LOOP;\r\n    ELSE\r\n      FOR func_oid IN SELECT oid\r\n                      FROM pg_proc\r\n                      WHERE pronamespace = src_oid AND not proisagg\r\n      LOOP\r\n        cnt := cnt + 1;\r\n        SELECT pg_get_functiondef(func_oid) INTO qry;\r\n        SELECT replace(qry, quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.') INTO dest_qry;\r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%;', dest_qry;\r\n        ELSE\r\n          EXECUTE dest_qry;\r\n        END IF;\r\n      END LOOP;\r\n    END IF;\r\n  \r\n    -- Create aggregate functions.\r\n    -- Fixed Issue#65\r\n    -- FOR func_oid IN SELECT oid FROM pg_proc WHERE pronamespace = src_oid AND prokind = 'a'\r\n    IF is_prokind THEN\r\n      FOR func_oid IN\r\n          SELECT oid\r\n          FROM pg_proc\r\n          WHERE pronamespace = src_oid AND prokind = 'a'\r\n      LOOP\r\n        cnt := cnt + 1;\r\n        SELECT\r\n          'CREATE AGGREGATE '\r\n          || dest_schema\r\n          || '.'\r\n          || p.proname\r\n          || '('\r\n          -- || format_type(a.aggtranstype, NULL)\r\n          -- Issue#65 Fixes for specific datatype mappings\r\n          || CASE WHEN format_type(a.aggtranstype, NULL) = 'double precision[]' THEN 'float8'\r\n                  WHEN format_type(a.aggtranstype, NULL) = 'anyarray'           THEN 'anyelement'\r\n             ELSE format_type(a.aggtranstype, NULL) END\r\n          || ') (sfunc = '\r\n          || regexp_replace(a.aggtransfn::text, '(^|\\W)' || quote_ident(source_schema) || '\\.', '\\1' || quote_ident(dest_schema) || '.')\r\n          || ', stype = '\r\n          -- || format_type(a.aggtranstype, NULL)\r\n          -- Issue#65 Fixes for specific datatype mappings\r\n          || CASE WHEN format_type(a.aggtranstype, NULL) = 'double precision[]' THEN 'float8[]' ELSE format_type(a.aggtranstype, NULL) END\r\n          || CASE\r\n              WHEN op.oprname IS NULL THEN ''\r\n              ELSE ', sortop = ' || op.oprname\r\n            END\r\n          || CASE\r\n              WHEN a.agginitval IS NULL THEN ''\r\n              ELSE ', initcond = ''' || a.agginitval || ''''\r\n            END\r\n          || ')'\r\n        INTO dest_qry\r\n        FROM pg_proc p\r\n        JOIN pg_aggregate a ON a.aggfnoid = p.oid\r\n        LEFT JOIN pg_operator op ON op.oid = a.aggsortop\r\n        WHERE p.oid = func_oid;\r\n  \r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%;', dest_qry;\r\n        ELSE\r\n          EXECUTE dest_qry;\r\n        END IF;\r\n  \r\n      END LOOP;\r\n      RAISE NOTICE '   FUNCTIONS cloned: %', LPAD(cnt::text, 5, ' ');\r\n  \r\n    ELSE\r\n      FOR func_oid IN SELECT oid FROM pg_proc WHERE pronamespace = src_oid AND proisagg\r\n      LOOP\r\n        cnt := cnt + 1;\r\n        SELECT\r\n          'CREATE AGGREGATE '\r\n          || dest_schema\r\n          || '.'\r\n          || p.proname\r\n          || '('\r\n          -- || format_type(a.aggtranstype, NULL)\r\n          -- Issue#65 Fixes for specific datatype mappings\r\n          || CASE WHEN format_type(a.aggtranstype, NULL) = 'double precision[]' THEN 'float8'\r\n                  WHEN format_type(a.aggtranstype, NULL) = 'anyarray'           THEN 'anyelement'\r\n             ELSE format_type(a.aggtranstype, NULL) END\r\n          || ') (sfunc = '\r\n          || regexp_replace(a.aggtransfn::text, '(^|\\W)' || quote_ident(source_schema) || '\\.', '\\1' || quote_ident(dest_schema) || '.')\r\n          || ', stype = '\r\n          -- || format_type(a.aggtranstype, NULL)\r\n          -- Issue#65 Fixes for specific datatype mappings\r\n          || CASE WHEN format_type(a.aggtranstype, NULL) = 'double precision[]' THEN 'float8[]' ELSE format_type(a.aggtranstype, NULL) END\r\n          || CASE\r\n              WHEN op.oprname IS NULL THEN ''\r\n              ELSE ', sortop = ' || op.oprname\r\n            END\r\n          || CASE\r\n              WHEN a.agginitval IS NULL THEN ''\r\n              ELSE ', initcond = ''' || a.agginitval || ''''\r\n            END\r\n          || ')'\r\n        INTO dest_qry\r\n        FROM pg_proc p\r\n        JOIN pg_aggregate a ON a.aggfnoid = p.oid\r\n        LEFT JOIN pg_operator op ON op.oid = a.aggsortop\r\n        WHERE p.oid = func_oid;\r\n  \r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%;', dest_qry;\r\n        ELSE\r\n          EXECUTE dest_qry;\r\n        END IF;\r\n  \r\n      END LOOP;\r\n      RAISE NOTICE '   FUNCTIONS cloned: %', LPAD(cnt::text, 5, ' ');\r\n    END IF;\r\n  \r\n  -- Create views\r\n  action := 'Views';\r\n\r\n  -- Issue#61 FIX: use set_config for empty string\r\n  -- MJV FIX #43: also had to reset search_path from source schema to empty.\r\n  -- SET search_path = '';\r\n  SELECT set_config('search_path', '', false)\r\n  INTO v_dummy;\r\n\r\n  cnt := 0;\r\n  --FOR object IN\r\n    -- SELECT table_name::text, view_definition\r\n    -- FROM information_schema.views\r\n    -- WHERE table_schema = quote_ident(source_schema)\r\n\r\n  -- Issue#73 replace loop query to handle dependencies\r\n  -- Issue#91 get view_owner\r\n  FOR srctbl, aname, view_owner, object IN\r\n    WITH RECURSIVE views AS (\r\n       SELECT n.nspname as schemaname, v.relname as tablename, v.oid::regclass AS viewname,\r\n              v.relkind = 'm' AS is_materialized, quote_ident( pg_catalog.pg_get_userbyid(v.relowner) ) as owner, \r\n              1 AS level\r\n       FROM pg_depend AS d\r\n          JOIN pg_rewrite AS r\r\n             ON r.oid = d.objid\r\n          JOIN pg_class AS v\r\n             ON v.oid = r.ev_class\r\n          JOIN pg_namespace n\r\n             ON n.oid = v.relnamespace\r\n       -- WHERE v.relkind IN ('v', 'm')\r\n       WHERE v.relkind IN ('v')\r\n         AND d.classid = 'pg_rewrite'::regclass\r\n         AND d.refclassid = 'pg_class'::regclass\r\n         AND d.deptype = 'n'\r\n    UNION\r\n       -- add the views that depend on these\r\n       SELECT n.nspname as schemaname, v.relname as tablename, v.oid::regclass AS viewname,\r\n              v.relkind = 'm', quote_ident( pg_catalog.pg_get_userbyid(v.relowner) ) as owner, \r\n              views.level + 1\r\n       FROM views\r\n          JOIN pg_depend AS d\r\n             ON d.refobjid = views.viewname\r\n          JOIN pg_rewrite AS r\r\n             ON r.oid = d.objid\r\n          JOIN pg_class AS v\r\n             ON v.oid = r.ev_class\r\n          JOIN pg_namespace n\r\n             ON n.oid = v.relnamespace\r\n       -- WHERE v.relkind IN ('v', 'm')\r\n       WHERE v.relkind IN ('v')\r\n         AND d.classid = 'pg_rewrite'::regclass\r\n             AND d.refclassid = 'pg_class'::regclass\r\n         AND d.deptype = 'n'\r\n         AND v.oid <> views.viewname\r\n    )\r\n    SELECT tablename, viewname, owner, format('CREATE OR REPLACE%s VIEW %s AS%s',\r\n                  CASE WHEN is_materialized\r\n                       THEN ' MATERIALIZED'\r\n                       ELSE ''\r\n                  END,\r\n                  viewname,\r\n                  pg_get_viewdef(viewname))\r\n    FROM views\r\n    WHERE schemaname = quote_ident(source_schema)\r\n    GROUP BY schemaname, tablename, viewname, owner, is_materialized\r\n    ORDER BY max(level), schemaname, tablename\r\n  LOOP\r\n    cnt := cnt + 1;\r\n    -- Issue#73 replace logic based on new loop sql\r\n    buffer := quote_ident(dest_schema) || '.' || quote_ident(aname);\r\n    -- MJV FIX: #43\r\n    -- SELECT view_definition INTO v_def\r\n    -- SELECT REPLACE(view_definition, quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.') INTO v_def\r\n    -- FROM information_schema.views\r\n    -- WHERE table_schema = quote_ident(source_schema)\r\n    --   AND table_name = quote_ident(object);\r\n    SELECT REPLACE(object, quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.') INTO v_def;\r\n    -- NOTE: definition already includes the closing statement semicolon\r\n    SELECT REPLACE(aname, quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.') INTO buffer3;\r\n    IF bDDLOnly THEN\r\n      RAISE INFO '%', v_def;\r\n      -- Issue#91 Fix\r\n      -- issue#95 \r\n      IF NOT bNoOwner THEN\r\n        RAISE INFO 'ALTER TABLE % OWNER TO %', buffer3, view_owner || ';';\r\n      END IF;        \r\n    ELSE\r\n      -- EXECUTE 'CREATE OR REPLACE VIEW ' || buffer || ' AS ' || v_def;\r\n      EXECUTE v_def;\r\n      -- Issue#73: commented out comment logic for views since we do it elsewhere now.\r\n      -- Issue#91 Fix\r\n      -- issue#95 \r\n      IF NOT bNoOwner THEN      \r\n        v_def = 'ALTER TABLE ' || buffer3 || ' OWNER TO ' || view_owner || ';';\r\n        EXECUTE v_def;\r\n      END IF;\r\n    END IF;\r\n  END LOOP;\r\n  RAISE NOTICE '       VIEWS cloned: %', LPAD(cnt::text, 5, ' ');\r\n\r\n  -- Create Materialized views\r\n  action := 'Mat. Views';\r\n  cnt := 0;\r\n  -- Issue#91 get view_owner\r\n  FOR object, view_owner, v_def IN\r\n      SELECT matviewname::text, matviewowner::text, replace(definition,';','') FROM pg_catalog.pg_matviews WHERE schemaname = quote_ident(source_schema)\r\n  LOOP\r\n      cnt := cnt + 1;\r\n      -- Issue#78 FIX: handle case-sensitive names with quote_ident() on target schema and object\r\n      buffer := quote_ident(dest_schema) || '.' || quote_ident(object);\r\n\r\n      -- MJV FIX: #72 remove source schema in MV def\r\n      SELECT REPLACE(v_def, quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.') INTO buffer2;\r\n\r\n      IF bData THEN\r\n        -- issue#98 defer creation until after regular tables are populated. Also defer the ownership as well.\r\n        -- EXECUTE 'CREATE MATERIALIZED VIEW ' || buffer || ' AS ' || buffer2 || ' WITH DATA;' ;\r\n        buffer3 = 'CREATE MATERIALIZED VIEW ' || buffer || ' AS ' || buffer2 || ' WITH DATA;';\r\n        mvarray := mvarray || buffer3;\r\n        \r\n        -- issue#95 \r\n        IF NOT bNoOwner THEN      \r\n          -- buffer3 = 'ALTER MATERIALIZED VIEW ' || buffer || ' OWNER TO ' || view_owner || ';' ;\r\n          -- EXECUTE buffer3;\r\n          buffer3 = 'ALTER MATERIALIZED VIEW ' || buffer || ' OWNER TO ' || view_owner || ';' ;\r\n          mvarray := mvarray || buffer3;\r\n        END IF;\r\n      ELSE\r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%', 'CREATE MATERIALIZED VIEW ' || buffer || ' AS ' || buffer2 || ' WITH NO DATA;' ;\r\n          -- Issue#91\r\n          -- issue#95 \r\n          IF NOT bNoOwner THEN      \r\n            RAISE INFO '%', 'ALTER MATERIALIZED VIEW ' || buffer || ' OWNER TO ' || view_owner || ';' ;\r\n          END IF;\r\n        ELSE\r\n          EXECUTE 'CREATE MATERIALIZED VIEW ' || buffer || ' AS ' || buffer2 || ' WITH NO DATA;' ;\r\n          -- Issue#91\r\n          -- issue#95 \r\n          IF NOT bNoOwner THEN      \r\n            buffer3 = 'ALTER MATERIALIZED VIEW ' || buffer || ' OWNER TO ' || view_owner || ';' ;\r\n            EXECUTE buffer3;\r\n          END IF;\r\n        END IF;\r\n      END IF;\r\n      SELECT coalesce(obj_description(oid), '') into adef from pg_class where relkind = 'm' and relname = object;\r\n      IF adef <> '' THEN\r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%', 'COMMENT ON MATERIALIZED VIEW ' || quote_ident(dest_schema) || '.' || object || ' IS ''' || adef || ''';';\r\n        ELSE\r\n          -- Issue#$98: also defer if copy rows is on since we defer MVIEWS in that case\r\n          IF bData THEN\r\n            buffer3 = 'COMMENT ON MATERIALIZED VIEW ' || quote_ident(dest_schema) || '.' || object || ' IS ''' || adef || ''';';\r\n            mvarray = mvarray || buffer3;\r\n          ELSE\r\n            EXECUTE 'COMMENT ON MATERIALIZED VIEW ' || quote_ident(dest_schema) || '.' || object || ' IS ''' || adef || ''';';\r\n          END IF;\r\n          \r\n        END IF;\r\n      END IF;\r\n\r\n      FOR aname, adef IN\r\n        SELECT indexname, replace(indexdef, quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.') as newdef FROM pg_indexes where schemaname = quote_ident(source_schema) and tablename = object order by indexname\r\n      LOOP\r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%', adef || ';';\r\n        ELSE\r\n          EXECUTE adef || ';';\r\n        END IF;\r\n      END LOOP;\r\n\r\n  END LOOP;\r\n  RAISE NOTICE '   MAT VIEWS cloned: %', LPAD(cnt::text, 5, ' ');\r\n\r\n  -- Issue 90 Move create functions to before views\r\n  \r\n  -- MV: Create Triggers\r\n\r\n  -- MJV FIX: #38\r\n  -- EXECUTE 'SET search_path = ' || quote_ident(source_schema) ;\r\n\r\n  -- Issue#61 FIX: use set_config for empty string\r\n  -- SET search_path = '';\r\n  SELECT set_config('search_path', '', false) into v_dummy;\r\n\r\n  action := 'Triggers';\r\n  cnt := 0;\r\n  FOR arec IN\r\n    -- 2021-03-09 MJV FIX: #40 fixed sql to get the def using pg_get_triggerdef() sql\r\n    SELECT n.nspname, c.relname, t.tgname, p.proname, REPLACE(pg_get_triggerdef(t.oid), quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.') || ';' AS trig_ddl\r\n    FROM pg_trigger t, pg_class c, pg_namespace n, pg_proc p\r\n    WHERE n.nspname = quote_ident(source_schema)\r\n      AND n.oid = c.relnamespace\r\n      AND c.relkind in ('r','p')\r\n      AND n.oid = p.pronamespace\r\n      AND c.oid = t.tgrelid\r\n      AND p.oid = t.tgfoid\r\n      ORDER BY c.relname, t.tgname\r\n  LOOP\r\n    BEGIN\r\n      cnt := cnt + 1;\r\n      IF bDDLOnly THEN\r\n        RAISE INFO '%', arec.trig_ddl;\r\n      ELSE\r\n        EXECUTE arec.trig_ddl;\r\n      END IF;\r\n\r\n    END;\r\n  END LOOP;\r\n  RAISE NOTICE '    TRIGGERS cloned: %', LPAD(cnt::text, 5, ' ');\r\n\r\n\r\n  -- MV: Create Rules\r\n  -- Fixes Issue#59 Implement Rules\r\n  action := 'Rules';\r\n  cnt := 0;\r\n  FOR arec IN\r\n    SELECT regexp_replace(definition, E'[\\\\n\\\\r]+', ' ', 'g' ) as definition\r\n    FROM pg_rules\r\n    WHERE schemaname = quote_ident(source_schema)\r\n  LOOP\r\n    cnt := cnt + 1;\r\n    buffer := REPLACE(arec.definition, quote_ident(source_schema) || '.', quote_ident(dest_schema) || '.');\r\n    IF bDDLOnly THEN\r\n      RAISE INFO '%', buffer;\r\n    ELSE\r\n      EXECUTE buffer;\r\n    END IF;\r\n  END LOOP;\r\n  RAISE NOTICE '    RULES    cloned: %', LPAD(cnt::text, 5, ' ');\r\n\r\n\r\n  -- MV: Create Policies\r\n  -- Fixes Issue#66 Implement Security policies for RLS\r\n  action := 'Policies';\r\n  cnt := 0;\r\n  FOR arec IN\r\n    -- Issue#78 FIX: handle case-sensitive names with quote_ident() on policy, tablename\r\n    SELECT schemaname as schemaname, tablename as tablename, 'CREATE POLICY ' || policyname || ' ON ' || quote_ident(dest_schema) || '.' || quote_ident(tablename) || ' AS ' || permissive || ' FOR ' || cmd || ' TO '\r\n    ||  array_to_string(roles, ',', '*') || ' USING (' || regexp_replace(qual, E'[\\\\n\\\\r]+', ' ', 'g' ) || ')'\r\n    || CASE WHEN with_check IS NOT NULL THEN ' WITH CHECK (' ELSE '' END || coalesce(with_check, '') || CASE WHEN with_check IS NOT NULL THEN ');' ELSE ';' END as definition\r\n    FROM pg_policies\r\n    WHERE schemaname = quote_ident(source_schema)\r\n    ORDER BY policyname\r\n  LOOP\r\n    cnt := cnt + 1;\r\n    IF bDDLOnly THEN\r\n      RAISE INFO '%', arec.definition;\r\n    ELSE\r\n      EXECUTE arec.definition;\r\n    END IF;\r\n    \r\n    -- Issue#76: Enable row security if indicated\r\n    SELECT c.relrowsecurity INTO abool FROM pg_class c, pg_namespace n where n.nspname = quote_ident(arec.schemaname) AND n.oid = c.relnamespace AND c.relname = quote_ident(arec.tablename) and c.relkind = 'r';\r\n    IF abool THEN\r\n      buffer = 'ALTER TABLE ' || dest_schema || '.' || arec.tablename || ' ENABLE ROW LEVEL SECURITY;';\r\n      IF bDDLOnly THEN\r\n        RAISE INFO '%', buffer;\r\n      ELSE\r\n        EXECUTE buffer;\r\n      END IF;\r\n    END IF;\r\n  END LOOP;\r\n  RAISE NOTICE '    POLICIES cloned: %', LPAD(cnt::text, 5, ' ');\r\n\r\n\r\n  -- MJV Fixed #62 for comments (PASS 1)\r\n  action := 'Comments1';\r\n  cnt := 0;\r\n  FOR qry IN\r\n    -- Issue#74 Fix: Change schema from source to target. Also, do not include comments on foreign tables since we do not clone foreign tables at this time.\r\n    SELECT 'COMMENT ON ' || CASE WHEN c.relkind in ('r','p') AND a.attname IS NULL THEN 'TABLE ' WHEN c.relkind in ('r','p') AND\r\n    a.attname IS NOT NULL THEN 'COLUMN ' WHEN c.relkind = 'f' THEN 'FOREIGN TABLE ' WHEN c.relkind = 'm' THEN 'MATERIALIZED VIEW ' WHEN c.relkind = 'v' THEN 'VIEW '\r\n    WHEN c.relkind = 'i' THEN 'INDEX ' WHEN c.relkind = 'S' THEN 'SEQUENCE ' ELSE 'XX' END || quote_ident(dest_schema) || '.' || CASE WHEN c.relkind in ('r','p') AND\r\n    -- Issue#78: handle case-sensitive names with quote_ident()\r\n    a.attname IS NOT NULL THEN quote_ident(c.relname) || '.' || a.attname ELSE quote_ident(c.relname) END ||\r\n    -- Issue#74 Fix\r\n    -- ' IS ''' || d.description || ''';' as ddl\r\n    ' IS '   || quote_literal(d.description) || ';' as ddl\r\n    FROM pg_class c\r\n    JOIN pg_namespace n ON (n.oid = c.relnamespace)\r\n    LEFT JOIN pg_description d ON (c.oid = d.objoid)\r\n    LEFT JOIN pg_attribute a ON (c.oid = a.attrelid\r\n      AND a.attnum > 0 and a.attnum = d.objsubid)\r\n    WHERE c.relkind <> 'f' AND d.description IS NOT NULL AND n.nspname = quote_ident(source_schema)\r\n    ORDER BY ddl\r\n  LOOP\r\n    cnt := cnt + 1;\r\n    \r\n    -- BAD : \"COMMENT ON SEQUENCE sample_clone2.CaseSensitive_ID_seq IS 'just a comment on CaseSensitive sequence';\"\r\n    -- GOOD: \"COMMENT ON SEQUENCE \"CaseSensitive_ID_seq\" IS 'just a comment on CaseSensitive sequence';\"\r\n    \r\n    -- Issue#98 For MVs we create comments when we create the MVs\r\n    IF substring(qry,1,28) = 'COMMENT ON MATERIALIZED VIEW' THEN\r\n      IF bDebug THEN RAISE NOTICE 'DEBUG: deferring comments on MVs'; END IF;\r\n      cnt = cnt - 1;\r\n      continue;\r\n    END IF;\r\n    \r\n    IF bDDLOnly THEN\r\n      RAISE INFO '%', qry;\r\n    ELSE\r\n      EXECUTE qry;\r\n    END IF;\r\n  END LOOP;\r\n  RAISE NOTICE ' COMMENTS(1) cloned: %', LPAD(cnt::text, 5, ' ');\r\n\r\n  -- MJV Fixed #62 for comments (PASS 2)\r\n  action := 'Comments2';\r\n  cnt2 := 0;\r\n  IF is_prokind THEN\r\n  FOR qry IN\r\n    -- Issue#74 Fix: Change schema from source to target.\r\n    SELECT 'COMMENT ON SCHEMA ' || dest_schema ||\r\n    -- Issue#74 Fix\r\n    -- ' IS ''' || d.description || ''';' as ddl\r\n    ' IS '   || quote_literal(d.description) || ';' as ddl\r\n    from pg_namespace n, pg_description d where d.objoid = n.oid and n.nspname = quote_ident(source_schema)\r\n    UNION\r\n    -- Issue#74 Fix: need to replace source schema inline\r\n    -- SELECT 'COMMENT ON TYPE ' || pg_catalog.format_type(t.oid, NULL) || ' IS ''' || pg_catalog.obj_description(t.oid, 'pg_type') || ''';' as ddl\r\n    SELECT 'COMMENT ON TYPE ' || REPLACE(pg_catalog.format_type(t.oid, NULL), quote_ident(source_schema), quote_ident(dest_schema)) || ' IS ''' || pg_catalog.obj_description(t.oid, 'pg_type') || ''';' as ddl\r\n    FROM pg_catalog.pg_type t\r\n    JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\r\n    WHERE (t.typrelid = 0 OR (SELECT c.relkind = 'c' FROM pg_catalog.pg_class c WHERE c.oid = t.typrelid))\r\n      AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el WHERE el.oid = t.typelem AND el.typarray = t.oid)\r\n      AND n.nspname = quote_ident(source_schema) COLLATE pg_catalog.default\r\n      AND pg_catalog.obj_description(t.oid, 'pg_type') IS NOT NULL and t.typtype = 'c'\r\n    UNION\r\n    -- Issue#78: handle case-sensitive names with quote_ident()\r\n    SELECT 'COMMENT ON COLLATION ' || quote_ident(dest_schema) || '.' || quote_ident(c.collname) || ' IS ''' || pg_catalog.obj_description(c.oid, 'pg_collation') || ''';' as ddl\r\n    FROM pg_catalog.pg_collation c, pg_catalog.pg_namespace n\r\n    WHERE n.oid = c.collnamespace AND c.collencoding IN (-1, pg_catalog.pg_char_to_encoding(pg_catalog.getdatabaseencoding()))\r\n      AND n.nspname = quote_ident(source_schema) COLLATE pg_catalog.default AND pg_catalog.obj_description(c.oid, 'pg_collation') IS NOT NULL\r\n    UNION\r\n    SELECT 'COMMENT ON ' || CASE WHEN p.prokind = 'f' THEN 'FUNCTION ' WHEN p.prokind = 'p' THEN 'PROCEDURE ' WHEN p.prokind = 'a' THEN 'AGGREGATE ' END ||\r\n    dest_schema || '.' || p.proname || ' (' || oidvectortypes(p.proargtypes) || ')'\r\n    -- Issue#74 Fix\r\n    -- ' IS ''' || d.description || ''';' as ddl\r\n    ' IS '   || quote_literal(d.description) || ';' as ddl\r\n    FROM pg_catalog.pg_namespace n\r\n    JOIN pg_catalog.pg_proc p ON p.pronamespace = n.oid\r\n    JOIN pg_description d ON (d.objoid = p.oid)\r\n    WHERE n.nspname = quote_ident(source_schema)\r\n    UNION\r\n    SELECT 'COMMENT ON POLICY ' || p1.policyname || ' ON ' || dest_schema || '.' || p1.tablename ||\r\n    -- Issue#74 Fix\r\n    -- ' IS ''' || d.description || ''';' as ddl\r\n    ' IS '   || quote_literal(d.description) || ';' as ddl\r\n    FROM pg_policies p1, pg_policy p2, pg_class c, pg_namespace n, pg_description d\r\n    WHERE p1.schemaname = n.nspname AND p1.tablename = c.relname AND n.oid = c.relnamespace\r\n      AND c.relkind in ('r','p') AND p1.policyname = p2.polname AND d.objoid = p2.oid AND p1.schemaname = quote_ident(source_schema)\r\n    UNION\r\n    SELECT 'COMMENT ON DOMAIN ' || dest_schema || '.' || t.typname ||\r\n    -- Issue#74 Fix\r\n    -- ' IS ''' || d.description || ''';' as ddl\r\n    ' IS '   || quote_literal(d.description) || ';' as ddl\r\n    FROM pg_catalog.pg_type t\r\n    LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\r\n    JOIN pg_catalog.pg_description d ON d.classoid = t.tableoid AND d.objoid = t.oid AND d.objsubid = 0\r\n    WHERE t.typtype = 'd' AND n.nspname = quote_ident(source_schema) COLLATE pg_catalog.default\r\n    ORDER BY 1\r\n  LOOP\r\n    cnt2 := cnt2 + 1;\r\n    IF bDDLOnly THEN\r\n      RAISE INFO '%', qry;\r\n    ELSE\r\n      EXECUTE qry;\r\n    END IF;\r\n  END LOOP;\r\n  ELSE -- must be v 10 or less\r\n  FOR qry IN\r\n    -- Issue#74 Fix: Change schema from source to target.\r\n    SELECT 'COMMENT ON SCHEMA ' || dest_schema ||\r\n    -- Issue#74 Fix\r\n    -- ' IS ''' || d.description || ''';' as ddl\r\n    ' IS '   || quote_literal(d.description) || ';' as ddl\r\n    from pg_namespace n, pg_description d where d.objoid = n.oid and n.nspname = quote_ident(source_schema)\r\n    UNION\r\n    -- Issue#74 Fix: need to replace source schema inline\r\n    -- SELECT 'COMMENT ON TYPE ' || pg_catalog.format_type(t.oid, NULL) || ' IS ''' || pg_catalog.obj_description(t.oid, 'pg_type') || ''';' as ddl\r\n    SELECT 'COMMENT ON TYPE ' || REPLACE(pg_catalog.format_type(t.oid, NULL), quote_ident(source_schema), quote_ident(dest_schema)) || ' IS ''' || pg_catalog.obj_description(t.oid, 'pg_type') || ''';' as ddl\r\n    FROM pg_catalog.pg_type t\r\n    JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\r\n    WHERE (t.typrelid = 0 OR (SELECT c.relkind = 'c'\r\n                              FROM pg_catalog.pg_class c\r\n                              WHERE c.oid = t.typrelid))\r\n      AND NOT EXISTS(SELECT 1 FROM pg_catalog.pg_type el\r\n                     WHERE el.oid = t.typelem AND el.typarray = t.oid)\r\n      AND n.nspname = quote_ident(source_schema) COLLATE pg_catalog.default\r\n      AND pg_catalog.obj_description(t.oid, 'pg_type') IS NOT NULL and t.typtype = 'c'\r\n    UNION\r\n    -- FIX Isse#87 by adding double quotes around collation name\r\n    SELECT 'COMMENT ON COLLATION ' || dest_schema || '.\"' || c.collname || '\" IS ''' || pg_catalog.obj_description(c.oid, 'pg_collation') || ''';' as ddl\r\n    FROM pg_catalog.pg_collation c, pg_catalog.pg_namespace n\r\n    WHERE n.oid = c.collnamespace AND c.collencoding IN (-1, pg_catalog.pg_char_to_encoding(pg_catalog.getdatabaseencoding()))\r\n      AND n.nspname = quote_ident(source_schema) COLLATE pg_catalog.default AND pg_catalog.obj_description(c.oid, 'pg_collation') IS NOT NULL\r\n    UNION\r\n    SELECT 'COMMENT ON ' || CASE WHEN proisagg THEN 'AGGREGATE ' ELSE 'FUNCTION ' END ||\r\n    dest_schema || '.' || p.proname || ' (' || oidvectortypes(p.proargtypes) || ')'\r\n    -- Issue#74 Fix\r\n    -- ' IS ''' || d.description || ''';' as ddl\r\n    ' IS '   || quote_literal(d.description) || ';' as ddl\r\n    FROM pg_catalog.pg_namespace n\r\n    JOIN pg_catalog.pg_proc p ON p.pronamespace = n.oid\r\n    JOIN pg_description d ON (d.objoid = p.oid)\r\n    WHERE n.nspname = quote_ident(source_schema)\r\n    UNION\r\n    SELECT 'COMMENT ON POLICY ' || p1.policyname || ' ON ' || dest_schema || '.' || p1.tablename ||\r\n    -- Issue#74 Fix\r\n    -- ' IS ''' || d.description || ''';' as ddl\r\n    ' IS '   || quote_literal(d.description) || ';' as ddl\r\n    FROM pg_policies p1, pg_policy p2, pg_class c, pg_namespace n, pg_description d\r\n    WHERE p1.schemaname = n.nspname AND p1.tablename = c.relname AND n.oid = c.relnamespace\r\n      AND c.relkind in ('r','p') AND p1.policyname = p2.polname AND d.objoid = p2.oid AND p1.schemaname = quote_ident(source_schema)\r\n    UNION\r\n    SELECT 'COMMENT ON DOMAIN ' || dest_schema || '.' || t.typname ||\r\n    -- Issue#74 Fix\r\n    -- ' IS ''' || d.description || ''';' as ddl\r\n    ' IS '   || quote_literal(d.description) || ';' as ddl\r\n    FROM pg_catalog.pg_type t\r\n    LEFT JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace\r\n    JOIN pg_catalog.pg_description d ON d.classoid = t.tableoid AND d.objoid = t.oid AND d.objsubid = 0\r\n    WHERE t.typtype = 'd' AND n.nspname = quote_ident(source_schema) COLLATE pg_catalog.default\r\n    ORDER BY 1\r\n  LOOP\r\n    cnt2 := cnt2 + 1;\r\n    IF bDDLOnly THEN\r\n      RAISE INFO '%', qry;\r\n    ELSE\r\n      EXECUTE qry;\r\n    END IF;\r\n  END LOOP;\r\n  END IF;\r\n  RAISE NOTICE ' COMMENTS(2) cloned: %', LPAD(cnt2::text, 5, ' ');\r\n\r\n\r\n  -- Issue#95 bypass if No ACL specified.\r\n  IF NOT bNoACL THEN\r\n    -- ---------------------\r\n    -- MV: Permissions: Defaults\r\n    -- ---------------------\r\n    EXECUTE 'SET search_path = ' || quote_ident(source_schema) ;\r\n    action := 'PRIVS: Defaults';\r\n    cnt := 0;\r\n    FOR arec IN\r\n      SELECT pg_catalog.pg_get_userbyid(d.defaclrole) AS \"owner\", n.nspname AS schema,\r\n      CASE d.defaclobjtype WHEN 'r' THEN 'table' WHEN 'S' THEN 'sequence' WHEN 'f' THEN 'function' WHEN 'T' THEN 'type' WHEN 'n' THEN 'schema' END AS atype,\r\n      d.defaclacl as defaclacl, pg_catalog.array_to_string(d.defaclacl, ',') as defaclstr\r\n      FROM pg_catalog.pg_default_acl d LEFT JOIN pg_catalog.pg_namespace n ON (n.oid = d.defaclnamespace)\r\n      WHERE n.nspname IS NOT NULL AND n.nspname = quote_ident(source_schema)\r\n      ORDER BY 3, 2, 1\r\n    LOOP\r\n      BEGIN\r\n        -- RAISE NOTICE ' owner=%  type=%  defaclacl=%  defaclstr=%', quote_ident( arec.owner ), arec.atype, arec.defaclacl, arec.defaclstr;\r\n\r\n        FOREACH aclstr IN ARRAY arec.defaclacl\r\n        LOOP\r\n            cnt := cnt + 1;\r\n            -- RAISE NOTICE ' aclstr=%', aclstr;\r\n            -- break up into grantor, grantee, and privs, mydb_update=rwU/mydb_owner\r\n            SELECT quote_ident( split_part(aclstr, '=',1) ) INTO grantee;\r\n            SELECT split_part(aclstr, '=',2) INTO grantor;\r\n            SELECT split_part(grantor, '/',1) INTO privs;\r\n            SELECT quote_ident( split_part(grantor, '/',2) ) INTO grantor;\r\n            -- RAISE NOTICE ' grantor=%  grantee=%  privs=%', grantor, grantee, privs;\r\n\r\n            IF arec.atype = 'function' THEN\r\n              -- Just having execute is enough to grant all apparently.\r\n              buffer := 'ALTER DEFAULT PRIVILEGES FOR ROLE ' || grantor || ' IN SCHEMA ' || quote_ident(dest_schema) || ' GRANT ALL ON FUNCTIONS TO \"' || grantee || '\";';\r\n            \r\n              -- Issue#92 Fix\r\n              -- set role = cm_stage_ro_grp;\r\n              -- ALTER DEFAULT PRIVILEGES FOR ROLE cm_stage_ro_grp IN SCHEMA cm_stage GRANT REFERENCES, TRIGGER ON TABLES TO cm_stage_ro_grp;            \r\n              IF grantor = grantee THEN\r\n                  -- append set role to statement\r\n                  buffer = 'SET ROLE = ' || grantor || '; ' || buffer;\r\n              END IF;\r\n            \r\n              IF bDDLOnly THEN\r\n                RAISE INFO '%', buffer;\r\n              ELSE\r\n                EXECUTE buffer;\r\n              END IF;\r\n              -- Issue#92 Fix:\r\n              EXECUTE 'SET ROLE = ' || calleruser;\r\n            \r\n            ELSIF arec.atype = 'sequence' THEN\r\n              IF POSITION('r' IN privs) > 0 AND POSITION('w' IN privs) > 0 AND POSITION('U' IN privs) > 0 THEN\r\n                -- arU is enough for all privs\r\n                buffer := 'ALTER DEFAULT PRIVILEGES FOR ROLE ' || grantor || ' IN SCHEMA ' || quote_ident(dest_schema) || ' GRANT ALL ON SEQUENCES TO \"' || grantee || '\";';\r\n              \r\n                -- Issue#92 Fix\r\n                IF grantor = grantee THEN\r\n                    -- append set role to statement\r\n                    buffer = 'SET ROLE = ' || grantor || '; ' || buffer;\r\n                END IF;\r\n\r\n                IF bDDLOnly THEN\r\n                  RAISE INFO '%', buffer;\r\n                ELSE\r\n                  EXECUTE buffer;\r\n                END IF;\r\n                -- Issue#92 Fix:\r\n                EXECUTE 'SET ROLE = ' || calleruser;\r\n\r\n              ELSE\r\n                -- have to specify each priv individually\r\n                buffer2 := '';\r\n                IF POSITION('r' IN privs) > 0 THEN\r\n                      buffer2 := 'SELECT';\r\n                END IF;\r\n                IF POSITION('w' IN privs) > 0 THEN\r\n                  IF buffer2 = '' THEN\r\n                    buffer2 := 'UPDATE';\r\n                  ELSE\r\n                    buffer2 := buffer2 || ', UPDATE';\r\n                  END IF;\r\n                END IF;\r\n                IF POSITION('U' IN privs) > 0 THEN\r\n                      IF buffer2 = '' THEN\r\n                    buffer2 := 'USAGE';\r\n                  ELSE\r\n                    buffer2 := buffer2 || ', USAGE';\r\n                  END IF;\r\n                END IF;\r\n                buffer := 'ALTER DEFAULT PRIVILEGES FOR ROLE ' || grantor || ' IN SCHEMA ' || quote_ident(dest_schema) || ' GRANT ' || buffer2 || ' ON SEQUENCES TO \"' || grantee || '\";';\r\n\r\n                -- Issue#92 Fix\r\n                IF grantor = grantee THEN\r\n                    -- append set role to statement\r\n                    buffer = 'SET ROLE = ' || grantor || '; ' || buffer;\r\n                END IF;\r\n              \r\n                IF bDDLOnly THEN\r\n                  RAISE INFO '%', buffer;\r\n                ELSE\r\n                  EXECUTE buffer;\r\n                END IF;\r\n                select current_user into buffer;\r\n                -- Issue#92 Fix:\r\n                EXECUTE 'SET ROLE = ' || calleruser;\r\n              END IF;\r\n\r\n            ELSIF arec.atype = 'table' THEN\r\n              -- do each priv individually, jeeeesh!\r\n              buffer2 := '';\r\n              IF POSITION('a' IN privs) > 0 THEN\r\n                buffer2 := 'INSERT';\r\n              END IF;\r\n              IF POSITION('r' IN privs) > 0 THEN\r\n                IF buffer2 = '' THEN\r\n                  buffer2 := 'SELECT';\r\n                ELSE\r\n                  buffer2 := buffer2 || ', SELECT';\r\n                END IF;\r\n              END IF;\r\n              IF POSITION('w' IN privs) > 0 THEN\r\n                IF buffer2 = '' THEN\r\n                  buffer2 := 'UPDATE';\r\n                ELSE\r\n                  buffer2 := buffer2 || ', UPDATE';\r\n                END IF;\r\n              END IF;\r\n              IF POSITION('d' IN privs) > 0 THEN\r\n                IF buffer2 = '' THEN\r\n                  buffer2 := 'DELETE';\r\n                ELSE\r\n                  buffer2 := buffer2 || ', DELETE';\r\n                END IF;\r\n              END IF;\r\n              IF POSITION('t' IN privs) > 0 THEN\r\n                IF buffer2 = '' THEN\r\n                  buffer2 := 'TRIGGER';\r\n                ELSE\r\n                  buffer2 := buffer2 || ', TRIGGER';\r\n                END IF;\r\n              END IF;\r\n              IF POSITION('T' IN privs) > 0 THEN\r\n                IF buffer2 = '' THEN\r\n                  buffer2 := 'TRUNCATE';\r\n                ELSE\r\n                  buffer2 := buffer2 || ', TRUNCATE';\r\n                END IF;\r\n              END IF;\r\n              buffer := 'ALTER DEFAULT PRIVILEGES FOR ROLE ' || grantor || ' IN SCHEMA ' || quote_ident(dest_schema) || ' GRANT ' || buffer2 || ' ON TABLES TO \"' || grantee || '\";';\r\n            \r\n              -- Issue#92 Fix\r\n              IF grantor = grantee THEN\r\n                  -- append set role to statement\r\n                  buffer = 'SET ROLE = ' || grantor || '; ' || buffer;\r\n              END IF;\r\n            \r\n              IF bDDLOnly THEN\r\n                RAISE INFO '%', buffer;\r\n              ELSE\r\n                EXECUTE buffer;\r\n              END IF;\r\n              select current_user into buffer;\r\n              -- Issue#92 Fix:\r\n              EXECUTE 'SET ROLE = ' || calleruser;\r\n\r\n            ELSIF arec.atype = 'type' THEN\r\n              IF POSITION('r' IN privs) > 0 AND POSITION('w' IN privs) > 0 AND POSITION('U' IN privs) > 0 THEN\r\n                -- arU is enough for all privs\r\n                buffer := 'ALTER DEFAULT PRIVILEGES FOR ROLE ' || grantor || ' IN SCHEMA ' || quote_ident(dest_schema) || ' GRANT ALL ON TYPES TO \"' || grantee || '\";';\r\n                \r\n                -- Issue#92 Fix\r\n                IF grantor = grantee THEN\r\n                    -- append set role to statement\r\n                    buffer = 'SET ROLE = ' || grantor || '; ' || buffer;\r\n                END IF;\r\n              \r\n                IF bDDLOnly THEN\r\n                  RAISE INFO '%', buffer;\r\n                ELSE\r\n                  EXECUTE buffer;\r\n                END IF;\r\n                -- Issue#92 Fix:\r\n                EXECUTE 'SET ROLE = ' || calleruser;\r\n              \r\n              ELSIF POSITION('U' IN privs) THEN\r\n                buffer := 'ALTER DEFAULT PRIVILEGES FOR ROLE ' || grantor || ' IN SCHEMA ' || quote_ident(dest_schema) || ' GRANT USAGE ON TYPES TO \"' || grantee || '\";';\r\n              \r\n                -- Issue#92 Fix\r\n                IF grantor = grantee THEN\r\n                    -- append set role to statement\r\n                    buffer = 'SET ROLE = ' || grantor || '; ' || buffer;\r\n                END IF;\r\n              \r\n                IF bDDLOnly THEN\r\n                  RAISE INFO '%', buffer;\r\n                ELSE\r\n                  EXECUTE buffer;\r\n                END IF;\r\n                -- Issue#92 Fix:\r\n                EXECUTE 'SET ROLE = ' || calleruser;\r\n              \r\n              ELSE\r\n                RAISE WARNING 'Unhandled TYPE Privs:: type=%  privs=%  owner=%   defaclacl=%  defaclstr=%  grantor=%  grantee=% ', arec.atype, privs, quote_ident( arec.owner ), arec.defaclacl, arec.defaclstr, grantor, grantee;\r\n            END IF;\r\n          ELSE\r\n            RAISE WARNING 'Unhandled Privs:: type=%  privs=%  owner=%   defaclacl=%  defaclstr=%  grantor=%  grantee=% ', arec.atype, privs, quote_ident( arec.owner ), arec.defaclacl, arec.defaclstr, grantor, grantee;\r\n          END IF;\r\n        END LOOP;\r\n      END;\r\n    END LOOP;\r\n  \r\n    RAISE NOTICE '  DFLT PRIVS cloned: %', LPAD(cnt::text, 5, ' ');    \r\n  END IF; -- NO ACL BRANCH\r\n\r\n  -- Issue#95 bypass if No ACL specified\r\n  IF NOT bNoACL THEN\r\n    -- MV: PRIVS: schema\r\n    -- crunchy data extension, check_access\r\n    -- SELECT role_path, base_role, as_role, objtype, schemaname, objname, array_to_string(array_agg(privname),',') as privs  FROM all_access()\r\n    -- WHERE base_role != CURRENT_USER and objtype = 'schema' and schemaname = 'public' group by 1,2,3,4,5,6;\r\n\r\n    action := 'PRIVS: Schema';\r\n    cnt := 0;\r\n    FOR arec IN\r\n      SELECT 'GRANT ' || p.perm::perm_type || ' ON SCHEMA ' || quote_ident(dest_schema) || ' TO ' || quote_ident( r.rolname ) || ';' as schema_ddl\r\n      FROM pg_catalog.pg_namespace AS n\r\n      CROSS JOIN pg_catalog.pg_roles AS r\r\n      CROSS JOIN (VALUES ('USAGE'), ('CREATE')) AS p(perm)\r\n      WHERE n.nspname = quote_ident(source_schema) AND NOT r.rolsuper AND has_schema_privilege(r.oid, n.oid, p.perm)\r\n      ORDER BY r.rolname, p.perm::perm_type\r\n    LOOP\r\n      BEGIN\r\n        cnt := cnt + 1;\r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%', arec.schema_ddl;\r\n        ELSE\r\n          EXECUTE arec.schema_ddl;\r\n        END IF;\r\n  \r\n      END;\r\n    END LOOP;\r\n    RAISE NOTICE 'SCHEMA PRIVS cloned: %', LPAD(cnt::text, 5, ' ');\r\n  END IF; -- NO ACL BRANCH\r\n\r\n  -- Issue#95 bypass if No ACL specified\r\n  IF NOT bNoACL THEN\r\n    -- MV: PRIVS: sequences\r\n    action := 'PRIVS: Sequences';\r\n    cnt := 0;\r\n    FOR arec IN\r\n      -- Issue#78 FIX: handle case-sensitive names with quote_ident() on t.relname\r\n      SELECT 'GRANT ' || p.perm::perm_type || ' ON ' || quote_ident(dest_schema) || '.' || quote_ident(t.relname::text) || ' TO ' || quote_ident( r.rolname ) || ';' as seq_ddl\r\n      FROM pg_catalog.pg_class AS t\r\n      CROSS JOIN pg_catalog.pg_roles AS r\r\n      CROSS JOIN (VALUES ('SELECT'), ('USAGE'), ('UPDATE')) AS p(perm)\r\n      WHERE t.relnamespace::regnamespace::name = quote_ident(source_schema) AND t.relkind = 'S'  AND NOT r.rolsuper AND has_sequence_privilege(r.oid, t.oid, p.perm)\r\n    LOOP\r\n      BEGIN\r\n        cnt := cnt + 1;\r\n        -- IF bDebug THEN RAISE NOTICE 'DEBUG: ddl=%', arec.seq_ddl; END IF;\r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%', arec.seq_ddl;\r\n        ELSE\r\n          EXECUTE arec.seq_ddl;\r\n        END IF;\r\n      END;\r\n    END LOOP;\r\n    RAISE NOTICE '  SEQ. PRIVS cloned: %', LPAD(cnt::text, 5, ' ');\r\n  END IF; -- NO ACL BRANCH    \r\n\r\n  -- Issue#95 bypass if No ACL specified\r\n  IF NOT bNoACL THEN\r\n    -- MV: PRIVS: functions\r\n    action := 'PRIVS: Functions/Procedures';\r\n    cnt := 0;\r\n\r\n    -- Issue#61 FIX: use set_config for empty string\r\n    -- SET search_path = '';\r\n    SELECT set_config('search_path', '', false) into v_dummy;\r\n\r\n    -- RAISE NOTICE ' source_schema=%  dest_schema=%',source_schema, dest_schema;\r\n    FOR arec IN\r\n      -- 2021-03-05 MJV FIX: issue#35: caused exception in some functions with parameters and gave privileges to other users that should not have gotten them.\r\n      -- SELECT 'GRANT EXECUTE ON FUNCTION ' || quote_ident(dest_schema) || '.' || replace(regexp_replace(f.oid::regprocedure::text, '^(((\"[^\"]*\")|([^\"][^.]*))\\.)?', ''), source_schema, dest_schema) || ' TO \"' || r.rolname || '\";' as func_ddl\r\n      -- FROM pg_catalog.pg_proc f CROSS JOIN pg_catalog.pg_roles AS r WHERE f.pronamespace::regnamespace::name = quote_ident(source_schema) AND NOT r.rolsuper AND has_function_privilege(r.oid, f.oid, 'EXECUTE')\r\n      -- order by regexp_replace(f.oid::regprocedure::text, '^(((\"[^\"]*\")|([^\"][^.]*))\\.)?', '')\r\n\r\n      -- 2021-03-05 MJV FIX: issue#37: defaults cause problems, use system function that returns args WITHOUT DEFAULTS\r\n      -- COALESCE(r.routine_type, 'FUNCTION'): for aggregate functions, information_schema.routines contains NULL as routine_type value.\r\n      -- Issue#78 FIX: handle case-sensitive names with quote_ident() on rp.routine_name\r\n      SELECT 'GRANT ' || rp.privilege_type || ' ON ' || COALESCE(r.routine_type, 'FUNCTION') || ' ' || quote_ident(dest_schema) || '.' || quote_ident(rp.routine_name) || ' (' || pg_get_function_identity_arguments(p.oid) || ') TO ' || string_agg(distinct quote_ident(rp.grantee ), ',') || ';' as func_dcl\r\n      FROM information_schema.routine_privileges rp, information_schema.routines r, pg_proc p, pg_namespace n\r\n      WHERE rp.routine_schema = quote_ident(source_schema)\r\n        AND rp.is_grantable = 'YES'\r\n        AND rp.routine_schema = r.routine_schema\r\n        AND rp.routine_name = r.routine_name\r\n        AND rp.routine_schema = n.nspname\r\n        AND n.oid = p.pronamespace\r\n        AND p.proname = r.routine_name\r\n      GROUP BY rp.privilege_type, r.routine_type, rp.routine_name, pg_get_function_identity_arguments(p.oid)\r\n    LOOP\r\n      BEGIN\r\n        cnt := cnt + 1;\r\n        IF bDDLOnly THEN\r\n          RAISE INFO '%', arec.func_dcl;\r\n        ELSE\r\n          EXECUTE arec.func_dcl;\r\n        END IF;\r\n      END;\r\n    END LOOP;\r\n    EXECUTE 'SET search_path = ' || quote_ident(source_schema) ;\r\n    RAISE NOTICE '  FUNC PRIVS cloned: %', LPAD(cnt::text, 5, ' ');\r\n  END IF; -- NO ACL BRANCH\r\n\r\n  -- Issue#95 bypass if No ACL specified\r\n  IF NOT bNoACL THEN\r\n    -- MV: PRIVS: tables\r\n    action := 'PRIVS: Tables';\r\n    -- regular, partitioned, and foreign tables plus view and materialized view permissions. Ignored for now: implement foreign table defs.\r\n    cnt := 0;\r\n    FOR arec IN\r\n      -- SELECT 'GRANT ' || p.perm::perm_type || CASE WHEN t.relkind in ('r', 'p', 'f') THEN ' ON TABLE ' WHEN t.relkind in ('v', 'm')  THEN ' ON ' END || quote_ident(dest_schema) || '.' || t.relname::text || ' TO \"' || r.rolname || '\";' as tbl_ddl,\r\n      -- has_table_privilege(r.oid, t.oid, p.perm) AS granted, t.relkind\r\n      -- FROM pg_catalog.pg_class AS t CROSS JOIN pg_catalog.pg_roles AS r CROSS JOIN (VALUES (TEXT 'SELECT'), ('INSERT'), ('UPDATE'), ('DELETE'), ('TRUNCATE'), ('REFERENCES'), ('TRIGGER')) AS p(perm)\r\n      -- WHERE t.relnamespace::regnamespace::name = quote_ident(source_schema)  AND t.relkind in ('r', 'p', 'f', 'v', 'm')  AND NOT r.rolsuper AND has_table_privilege(r.oid, t.oid, p.perm) order by t.relname::text, t.relkind\r\n      -- 2021-03-05  MJV FIX: Fixed Issue#36 for tables\r\n      SELECT c.relkind, 'GRANT ' || tb.privilege_type || CASE WHEN c.relkind in ('r', 'p') THEN ' ON TABLE ' WHEN c.relkind in ('v', 'm')  THEN ' ON ' END ||\r\n      -- Issue#78 FIX: handle case-sensitive names with quote_ident() on t.relname      \r\n      quote_ident(dest_schema) || '.' || quote_ident(tb.table_name) || ' TO ' || string_agg(quote_ident( tb.grantee ), ',') || ';' as tbl_dcl\r\n      FROM information_schema.table_privileges tb, pg_class c, pg_namespace n\r\n      WHERE tb.table_schema = quote_ident(source_schema) AND tb.table_name = c.relname AND c.relkind in ('r', 'p', 'v', 'm')\r\n        AND c.relnamespace = n.oid AND n.nspname = quote_ident(source_schema)\r\n        GROUP BY c.relkind, tb.privilege_type, tb.table_schema, tb.table_name\r\n    LOOP\r\n      BEGIN\r\n        cnt := cnt + 1;\r\n        -- IF bDebug THEN RAISE NOTICE 'DEBUG: ddl=%', arec.tbl_dcl; END IF;\r\n        -- Issue#46. Fixed reference to invalid record name (tbl_ddl --> tbl_dcl).\r\n        IF arec.relkind = 'f' THEN\r\n          RAISE WARNING 'Foreign tables are not currently implemented, so skipping privs for them. ddl=%', arec.tbl_dcl;\r\n        ELSE\r\n            IF bDDLOnly THEN\r\n                RAISE INFO '%', arec.tbl_dcl;\r\n            ELSE\r\n                EXECUTE arec.tbl_dcl;\r\n              END IF;\r\n      END IF;\r\n      END;\r\n    END LOOP;\r\n    RAISE NOTICE ' TABLE PRIVS cloned: %', LPAD(cnt::text, 5, ' ');\r\n  END IF; -- NO ACL BRANCH\r\n\r\n  -- LOOP for regular tables and populate them if specified\r\n  -- Issue#75 moved from big table loop above to here.\r\n  IF bData THEN\r\n    r = clock_timestamp();\r\n    -- IF bVerbose THEN RAISE NOTICE 'START: copy rows %',clock_timestamp() - t; END IF;  \r\n    IF bVerbose THEN RAISE NOTICE 'Copying rows...'; END IF;  \r\n\r\n    EXECUTE 'SET search_path = ' || quote_ident(dest_schema) ;\r\n    action := 'Copy Rows';\r\n    FOREACH tblelement IN ARRAY tblarray\r\n    LOOP \r\n       s = clock_timestamp();\r\n       IF bDebug THEN RAISE NOTICE 'DEBUG: no UDTs %', tblelement; END IF;\r\n       EXECUTE tblelement;       \r\n       GET DIAGNOSTICS cnt = ROW_COUNT;  \r\n       buffer = substring(tblelement, 13);\r\n       SELECT POSITION(' OVERRIDING SYSTEM VALUE SELECT ' IN buffer) INTO cnt2; \r\n       IF cnt2 = 0 THEN\r\n           SELECT POSITION(' SELECT ' IN buffer) INTO cnt2;\r\n           buffer = substring(buffer,1, cnt2);       \r\n       ELSE\r\n           buffer = substring(buffer,1, cnt2);       \r\n       END IF;\r\n       SELECT RPAD(buffer, 35, ' ') INTO buffer;\r\n       cnt2 := cast(extract(epoch from (clock_timestamp() - s)) as numeric(18,3));\r\n       IF bVerbose THEN RAISE NOTICE ' Populated cloned table, %   Rows Copied: %    seconds: %', buffer, LPAD(cnt::text, 10, ' '), LPAD(cnt2::text, 5, ' '); END IF;\r\n       tblscopied := tblscopied + 1;\r\n    END LOOP;\r\n    \r\n    -- Issue#79 implementation\r\n    -- Do same for tables with user-defined elements using copy to file method\r\n    FOREACH tblelement IN ARRAY tblarray2\r\n    LOOP \r\n       s = clock_timestamp();\r\n       IF bDebug THEN RAISE NOTICE 'DEBUG: UDTs %', tblelement; END IF;\r\n       EXECUTE tblelement;       \r\n       GET DIAGNOSTICS cnt = ROW_COUNT;  \r\n       cnt2 = POSITION(' FROM ' IN tblelement::text);\r\n       IF cnt2 > 0 THEN\r\n           buffer = substring(tblelement, 1, cnt2);\r\n           buffer = substring(buffer, 6);\r\n           SELECT RPAD(buffer, 35, ' ') INTO buffer;\r\n           cnt2 := cast(extract(epoch from (clock_timestamp() - s)) as numeric(18,3));\r\n           IF bVerbose THEN RAISE NOTICE ' Populated cloned table, %   Rows Copied: %    seconds: %', buffer, LPAD(cnt::text, 10, ' '), LPAD(cnt2::text, 5, ' '); END IF;\r\n           tblscopied := tblscopied + 1;\r\n       END IF;\r\n    END LOOP;    \r\n    \r\n    -- Issue#101 \r\n    -- Do same for tables with user-defined elements using direct method with text cast\r\n    FOREACH tblelement IN ARRAY tblarray3\r\n    LOOP \r\n       s = clock_timestamp();\r\n       IF bDebug THEN RAISE NOTICE 'DEBUG: UDTs %', tblelement; END IF;\r\n       EXECUTE tblelement;       \r\n       GET DIAGNOSTICS cnt = ROW_COUNT;  \r\n       cnt2 = POSITION(' (' IN tblelement::text);\r\n       IF cnt2 > 0 THEN\r\n           buffer = substring(tblelement, 1, cnt2);\r\n           buffer = substring(buffer, 6);\r\n           SELECT RPAD(buffer, 35, ' ') INTO buffer;\r\n           cnt2 := cast(extract(epoch from (clock_timestamp() - s)) as numeric(18,3));\r\n           IF bVerbose THEN RAISE NOTICE ' Populated cloned table, %   Rows Copied: %    seconds: %', buffer, LPAD(cnt::text, 10, ' '), LPAD(cnt2::text, 5, ' '); END IF;\r\n           tblscopied := tblscopied + 1;\r\n       END IF;\r\n    END LOOP;    \r\n    \r\n    \r\n    -- Issue#98 MVs deferred until now\r\n    FOREACH tblelement IN ARRAY mvarray\r\n    LOOP \r\n       s = clock_timestamp();\r\n       EXECUTE tblelement;       \r\n       -- get diagnostics for MV creates or refreshes does not work, always returns 1\r\n       GET DIAGNOSTICS cnt = ROW_COUNT;  \r\n       buffer = substring(tblelement, 25);\r\n       cnt2 = POSITION(' AS ' IN buffer);\r\n       IF cnt2 > 0 THEN\r\n         buffer = substring(buffer, 1, cnt2);\r\n         SELECT RPAD(buffer, 36, ' ') INTO buffer;\r\n         cnt2 := cast(extract(epoch from (clock_timestamp() - s)) as numeric(18,3));\r\n         IF bVerbose THEN RAISE NOTICE ' Populated Mat. View,   %   Rows Inserted:        ?    seconds: %', buffer, LPAD(cnt2::text, 5, ' '); END IF;\r\n         mvscopied := mvscopied + 1;\r\n       END IF;\r\n    END LOOP;    \r\n    \r\n    cnt := cast(extract(epoch from (clock_timestamp() - r)) as numeric(18,3));\r\n    IF bVerbose THEN RAISE NOTICE 'Copy rows duration: % seconds',cnt; END IF;  \r\n  END IF;\r\n  RAISE NOTICE '      TABLES copied: %', LPAD(tblscopied::text, 5, ' ');\r\n  RAISE NOTICE ' MATVIEWS refreshed: %', LPAD(mvscopied::text, 5, ' ');\r\n\r\n  \r\n  -- Issue#78 forces us to defer FKeys until the end since we previously did row copies before FKeys\r\n  --  add FK constraint\r\n  action := 'FK Constraints';\r\n  cnt := 0;\r\n\r\n  -- Issue#61 FIX: use set_config for empty string\r\n  -- SET search_path = '';\r\n  SELECT set_config('search_path', '', false) into v_dummy;\r\n\r\n  FOR qry IN\r\n    SELECT 'ALTER TABLE ' || quote_ident(dest_schema) || '.' || quote_ident(rn.relname)\r\n                          || ' ADD CONSTRAINT ' || quote_ident(ct.conname) || ' ' || REPLACE(pg_get_constraintdef(ct.oid), 'REFERENCES ' || quote_ident(source_schema) || '.', 'REFERENCES ' \r\n                          || quote_ident(dest_schema) || '.') || ';'\r\n    FROM pg_constraint ct\r\n    JOIN pg_class rn ON rn.oid = ct.conrelid\r\n    -- Issue#103 needed to addd this left join\r\n    LEFT JOIN pg_inherits i ON (rn.oid = i.inhrelid)\r\n    WHERE connamespace = src_oid\r\n        AND rn.relkind = 'r'\r\n        AND ct.contype = 'f'\r\n        -- Issue#103 fix: needed to also add this null check\r\n        AND i.inhrelid is null\r\n  LOOP\r\n    cnt := cnt + 1;\r\n    IF bDDLOnly THEN\r\n      RAISE INFO '%', qry;\r\n    ELSE\r\n      IF bDebug THEN RAISE NOTICE 'DEBUG: adding FKEY constraint: %', qry; END IF;\r\n      EXECUTE qry;\r\n    END IF;\r\n  END LOOP;\r\n  EXECUTE 'SET search_path = ' || quote_ident(source_schema) ;\r\n  RAISE NOTICE '       FKEYS cloned: %', LPAD(cnt::text, 5, ' ');\r\n\r\n\r\n  IF src_path_old = '' OR src_path_old = '\"\"' THEN\r\n    -- RAISE NOTICE 'Restoring old search_path to empty string';\r\n    SELECT set_config('search_path', '', false) into v_dummy;\r\n  ELSE\r\n    -- RAISE NOTICE 'Restoring old search_path to:%', src_path_old;\r\n    EXECUTE 'SET search_path = ' || src_path_old;\r\n  END IF;\r\n  SELECT setting INTO v_dummy FROM pg_settings WHERE name = 'search_path';\r\n  IF bDebug THEN RAISE NOTICE 'DEBUG: setting search_path back to what it was: %', v_dummy; END IF;\r\n  cnt := cast(extract(epoch from (clock_timestamp() - t)) as numeric(18,3));\r\n  IF bVerbose THEN RAISE NOTICE 'clone_schema duration: % seconds',cnt; END IF;  \r\n\r\n  EXCEPTION\r\n     WHEN others THEN\r\n     BEGIN\r\n         GET STACKED DIAGNOSTICS v_diag1 = MESSAGE_TEXT, v_diag2 = PG_EXCEPTION_DETAIL, v_diag3 = PG_EXCEPTION_HINT, v_diag4 = RETURNED_SQLSTATE, v_diag5 = PG_CONTEXT, v_diag6 = PG_EXCEPTION_CONTEXT;\r\n         -- v_ret := 'line=' || v_diag6 || '. '|| v_diag4 || '. ' || v_diag1 || ' .' || v_diag2 || ' .' || v_diag3;\r\n         v_ret := 'line=' || v_diag6 || '. '|| v_diag4 || '. ' || v_diag1;\r\n         -- Issue#101: added version to exception output\r\n         RAISE EXCEPTION 'Version: %  Action: %  Diagnostics: %',v_version, action, v_ret;\r\n\r\n         IF src_path_old = '' THEN\r\n           -- RAISE NOTICE 'setting old search_path to empty string';\r\n           SELECT set_config('search_path', '', false);\r\n         ELSE\r\n           -- RAISE NOTICE 'setting old search_path to:%', src_path_old;\r\n           EXECUTE 'SET search_path = ' || src_path_old;\r\n         END IF;\r\n\r\n         RETURN;\r\n     END;\r\n\r\nRETURN;\r\nEND;\r\n\r\n$function$"
}
function "public" "pgaudit_sql_drop" {
  schema     = schema.public
  args       = ""
  returns    = "event_trigger"
  language   = "c"
  definition = "SECURITY DEFINER\n SET search_path TO 'pg_catalog, pg_temp'\nAS '$libdir/pgaudit', $function$pgaudit_sql_drop$function$"
}
function "test" "set_current_timestamp_updated_at" {
  schema     = schema.test
  args       = ""
  returns    = "trigger"
  language   = "plpgsql"
  definition = "AS $function$\nDECLARE\n  _new record;\nBEGIN\n  _new := NEW;\n  _new.\"updated_at\" = NOW();\n  RETURN _new;\nEND;\n$function$"
}
function "test" "versioning" {
  schema     = schema.test
  args       = ""
  returns    = "trigger"
  language   = "plpgsql"
  definition = "AS $function$\r\nDECLARE\r\n  sys_period text;\r\n  history_table text;\r\n  manipulate jsonb;\r\n  ignore_unchanged_values bool;\r\n  commonColumns text[];\r\n  time_stamp_to_use timestamptz := current_timestamp;\r\n  range_lower timestamptz;\r\n  existing_range tstzrange;\r\n  newVersion record;\r\n  oldVersion record;\r\nBEGIN\r\n\r\n  sys_period := TG_ARGV[0];\r\n  history_table := TG_ARGV[1];\r\n  ignore_unchanged_values := TG_ARGV[3];\r\n\r\n\r\n  IF TG_OP = 'UPDATE' OR TG_OP = 'DELETE' THEN\r\n    -- Ignore rows already modified in the current transaction\r\n    IF OLD.xmin::text = (txid_current() % (2^32)::bigint)::text THEN\r\n      IF TG_OP = 'DELETE' THEN\r\n        RETURN OLD;\r\n      END IF;\r\n\r\n      RETURN NEW;\r\n    END IF;\r\n\r\n    EXECUTE format('SELECT $1.%I', sys_period) USING OLD INTO existing_range;\r\n\r\n    IF TG_ARGV[2] = 'true' THEN\r\n      -- mitigate update conflicts\r\n      range_lower := lower(existing_range);\r\n      IF range_lower >= time_stamp_to_use THEN\r\n        time_stamp_to_use := range_lower + interval '1 microseconds';\r\n      END IF;\r\n    END IF;\r\n\r\n    WITH history AS\r\n      (SELECT attname\r\n      FROM   pg_attribute\r\n      WHERE  attrelid = history_table::regclass\r\n      AND    attnum > 0\r\n      AND    NOT attisdropped),\r\n      main AS\r\n      (SELECT attname\r\n      FROM   pg_attribute\r\n      WHERE  attrelid = TG_RELID\r\n      AND    attnum > 0\r\n      AND    NOT attisdropped)\r\n    SELECT array_agg(quote_ident(history.attname)) INTO commonColumns\r\n      FROM history\r\n      INNER JOIN main\r\n      ON history.attname = main.attname\r\n      AND history.attname != sys_period;\r\n    -- skip version if it would be identical to the previous version\r\n    IF ignore_unchanged_values AND TG_OP = 'UPDATE' AND array_length(commonColumns, 1) > 0 THEN      EXECUTE 'SELECT ROW($1.' || array_to_string(commonColumns , ', $1.') || ')'\r\n        USING NEW\r\n        INTO newVersion;\r\n      EXECUTE 'SELECT ROW($1.' || array_to_string(commonColumns , ', $1.') || ')'\r\n        USING OLD\r\n        INTO oldVersion;\r\n      IF newVersion IS NOT DISTINCT FROM oldVersion THEN\r\n        RETURN NEW;\r\n      END IF;\r\n    END IF;\r\n    EXECUTE ('INSERT INTO ' ||\r\n      history_table ||\r\n      '(' ||\r\n      array_to_string(commonColumns , ',') ||\r\n      ',' ||\r\n      quote_ident(sys_period) ||\r\n      ') VALUES ($1.' ||\r\n      array_to_string(commonColumns, ',$1.') ||\r\n      ',tstzrange($2, $3, ''[)''))')\r\n       USING OLD, range_lower, time_stamp_to_use;\r\n  END IF;\r\n\r\n  IF TG_OP = 'UPDATE' OR TG_OP = 'INSERT' THEN\r\n    manipulate := jsonb_set('{}'::jsonb, ('{' || sys_period || '}')::text[], to_jsonb(tstzrange(time_stamp_to_use, null, '[)')));\r\n\r\n    RETURN jsonb_populate_record(NEW, manipulate);\r\n  END IF;\r\n\r\n  RETURN OLD;\r\nEND;\r\n$function$"
}
table "email" {
  schema = schema.test
  column "id" {
    null    = false
    type    = uuid
    default = sql("gen_random_uuid()")
  }
  column "created_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "updated_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "email" {
    null = false
    type = text
  }
  column "fid_email_status" {
    null = true
    type = uuid
  }
  column "sys_period" {
    null    = false
    type    = tstzrange
    default = sql("tstzrange(CURRENT_TIMESTAMP, NULL::timestamp with time zone)")
  }
  primary_key {
    columns = [column.id]
  }
  foreign_key "fk_fid_email_status" {
    columns     = [column.fid_email_status]
    ref_columns = [table.email_status.column.id]
    on_update   = NO_ACTION
    on_delete   = CASCADE
  }
  index "un_ml_fd_ml_stts" {
    unique  = true
    columns = [column.id, column.fid_email_status]
  }
}
table "email_status" {
  schema = schema.test
  column "id" {
    null    = false
    type    = uuid
    default = sql("gen_random_uuid()")
  }
  column "created_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "updated_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "status" {
    null = false
    type = text
  }
  column "sys_period" {
    null    = false
    type    = tstzrange
    default = sql("tstzrange(CURRENT_TIMESTAMP, NULL::timestamp with time zone)")
  }
  primary_key {
    columns = [column.id]
  }
}
table "h_email" {
  schema = schema.test
  column "id" {
    null = false
    type = uuid
  }
  column "created_at" {
    null = false
    type = timestamptz
  }
  column "updated_at" {
    null = false
    type = timestamptz
  }
  column "email" {
    null = false
    type = text
  }
  column "fid_email_status" {
    null = true
    type = uuid
  }
  column "sys_period" {
    null = false
    type = tstzrange
  }
  column "fid_h_email_status" {
    null = true
    type = uuid
  }
  foreign_key "fk_fid_h_email_status" {
    columns     = [column.fid_h_email_status, column.sys_period]
    ref_columns = [table.h_email_status.column.id, table.h_email_status.column.sys_period]
    on_update   = NO_ACTION
    on_delete   = NO_ACTION
  }
  index "h_email_un" {
    unique      = true
    constrained = true
    columns     = [column.fid_email_status]
  }
  index "h_emails_un" {
    unique      = true
    constrained = true
    columns     = [column.fid_h_email_status]
  }
}
table "h_email_status" {
  schema = schema.test
  column "id" {
    null = false
    type = uuid
  }
  column "created_at" {
    null = false
    type = timestamptz
  }
  column "updated_at" {
    null = false
    type = timestamptz
  }
  column "status" {
    null = false
    type = text
  }
  column "sys_period" {
    null = false
    type = tstzrange
  }
  index "h_email_status_un" {
    unique      = true
    constrained = true
    columns     = [column.id, column.sys_period]
  }
}
table "home" {
  schema = schema.test
  column "id" {
    null    = false
    type    = uuid
    default = sql("gen_random_uuid()")
  }
  column "created_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "updated_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "name" {
    null = false
    type = character_varying
  }
  column "fid_owner" {
    null = true
    type = uuid
  }
  primary_key {
    columns = [column.id]
  }
  foreign_key "fk_fid_owner" {
    columns     = [column.fid_owner]
    ref_columns = [table.person.column.id]
    on_update   = NO_ACTION
    on_delete   = CASCADE
  }
  index "un_hm_fd_wnr" {
    unique  = true
    columns = [column.id, column.fid_owner]
  }
}
table "person" {
  schema  = schema.test
  comment = "foo"
  column "id" {
    null    = false
    type    = uuid
    default = sql("gen_random_uuid()")
  }
  column "created_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "updated_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "name" {
    null = false
    type = text
  }
  column "phone" {
    null = true
    type = sql("character varying[]")
  }
  primary_key {
    columns = [column.id]
  }
  index "person_phone_idx" {
    unique  = true
    columns = [column.phone]
  }
  index "person_phone_unnnd" {
    unique             = true
    constrained        = true
    nulls_not_distinct = true
    columns            = [column.phone]
  }
}
table "ref_label" {
  schema = schema.test
  column "id" {
    null    = false
    type    = uuid
    default = sql("gen_random_uuid()")
  }
  column "created_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "updated_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "code" {
    null = false
    type = character_varying
  }
  column "label_en" {
    null = false
    type = character_varying
  }
  primary_key {
    columns = [column.id]
  }
}
table "rel_direction" {
  schema  = schema.test
  comment = "orientation de la maisons"
  column "id" {
    null    = false
    type    = uuid
    default = sql("gen_random_uuid()")
  }
  column "created_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "updated_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "fid_ref_label" {
    null = false
    type = uuid
  }
  column "fid_home" {
    null = false
    type = uuid
  }
  primary_key {
    columns = [column.id]
  }
  foreign_key "fk_fid_home" {
    columns     = [column.fid_home]
    ref_columns = [table.home.column.id]
    on_update   = NO_ACTION
    on_delete   = CASCADE
  }
  foreign_key "fk_fid_ref_label" {
    columns     = [column.fid_ref_label]
    ref_columns = [table.ref_label.column.id]
    on_update   = NO_ACTION
    on_delete   = CASCADE
  }
  index "un_rl_drctn_fd_rf_lbl_fd_hm" {
    unique  = true
    columns = [column.fid_ref_label, column.fid_home]
  }
}
table "rel_person_email" {
  schema = schema.test
  column "id" {
    null    = false
    type    = uuid
    default = sql("gen_random_uuid()")
  }
  column "created_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "updated_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "fid_email" {
    null = false
    type = uuid
  }
  column "fid_person" {
    null = false
    type = uuid
  }
  column "is_default" {
    null = true
    type = boolean
  }
  primary_key {
    columns = [column.id]
  }
  foreign_key "fk_fid_email" {
    columns     = [column.fid_email]
    ref_columns = [table.email.column.id]
    on_update   = NO_ACTION
    on_delete   = CASCADE
  }
  foreign_key "fk_fid_person" {
    columns     = [column.fid_person]
    ref_columns = [table.person.column.id]
    on_update   = NO_ACTION
    on_delete   = CASCADE
  }
  index "un_rl_prsn_ml_fd_ml" {
    unique  = true
    columns = [column.fid_email]
  }
  index "un_rl_prsn_ml_fd_ml_fd_prsn" {
    unique  = true
    columns = [column.fid_email, column.fid_person]
  }
}
table "rel_person_person" {
  schema = schema.test
  column "id" {
    null    = false
    type    = uuid
    default = sql("gen_random_uuid()")
  }
  column "created_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "updated_at" {
    null    = false
    type    = timestamptz
    default = sql("now()")
  }
  column "fid_person_src" {
    null = false
    type = uuid
  }
  column "fid_person_dst" {
    null = false
    type = uuid
  }
  primary_key {
    columns = [column.id]
  }
  foreign_key "fk_fid_person_dst" {
    columns     = [column.fid_person_dst]
    ref_columns = [table.person.column.id]
    on_update   = NO_ACTION
    on_delete   = CASCADE
  }
  foreign_key "fk_fid_person_src" {
    columns     = [column.fid_person_src]
    ref_columns = [table.person.column.id]
    on_update   = NO_ACTION
    on_delete   = CASCADE
  }
  index "un_rl_prsn_prsn_fd_prsn_src_fd_prsn_dst" {
    unique  = true
    columns = [column.fid_person_src, column.fid_person_dst]
  }
}
trigger "set_test_email_status_updated_at" {
  on      = table.test.email_status
  type    = "BEFORE"
  event   = "UPDATE"
  per     = "ROW"
  execute = function.test.set_current_timestamp_updated_at
  comment = "trigger to set value of column \"updated_at\" to current timestamp on row update"
}
trigger "set_test_email_updated_at" {
  on      = table.test.email
  type    = "BEFORE"
  event   = "UPDATE"
  per     = "ROW"
  execute = function.test.set_current_timestamp_updated_at
  comment = "trigger to set value of column \"updated_at\" to current timestamp on row update"
}
trigger "set_test_home_updated_at" {
  on      = table.test.home
  type    = "BEFORE"
  event   = "UPDATE"
  per     = "ROW"
  execute = function.test.set_current_timestamp_updated_at
  comment = "trigger to set value of column \"updated_at\" to current timestamp on row update"
}
trigger "set_test_person_updated_at" {
  on      = table.test.person
  type    = "BEFORE"
  event   = "UPDATE"
  per     = "ROW"
  execute = function.test.set_current_timestamp_updated_at
  comment = "trigger to set value of column \"updated_at\" to current timestamp on row update"
}
trigger "set_test_ref_label_updated_at" {
  on      = table.test.ref_label
  type    = "BEFORE"
  event   = "UPDATE"
  per     = "ROW"
  execute = function.test.set_current_timestamp_updated_at
  comment = "trigger to set value of column \"updated_at\" to current timestamp on row update"
}
trigger "set_test_rel_direction_updated_at" {
  on      = table.test.rel_direction
  type    = "BEFORE"
  event   = "UPDATE"
  per     = "ROW"
  execute = function.test.set_current_timestamp_updated_at
  comment = "trigger to set value of column \"updated_at\" to current timestamp on row update"
}
trigger "set_test_rel_person_email_updated_at" {
  on      = table.test.rel_person_email
  type    = "BEFORE"
  event   = "UPDATE"
  per     = "ROW"
  execute = function.test.set_current_timestamp_updated_at
  comment = "trigger to set value of column \"updated_at\" to current timestamp on row update"
}
trigger "set_test_rel_person_person_updated_at" {
  on      = table.test.rel_person_person
  type    = "BEFORE"
  event   = "UPDATE"
  per     = "ROW"
  execute = function.test.set_current_timestamp_updated_at
  comment = "trigger to set value of column \"updated_at\" to current timestamp on row update"
}
trigger "tgv_email" {
  on      = table.test.email
  type    = "BEFORE"
  event   = "INSERT OR UPDATE OR DELETE"
  per     = "ROW"
  execute = function.public.versioning
}
trigger "tgv_email_status" {
  on      = table.test.email_status
  type    = "BEFORE"
  event   = "INSERT OR UPDATE OR DELETE"
  per     = "ROW"
  execute = function.public.versioning
}
enum "cloneparms" {
  schema = schema.public
  values = ["DATA", "NODATA", "DDLONLY", "NOOWNER", "NOACL", "VERBOSE", "DEBUG", "FILECOPY"]
}
schema "public" {
  comment = "standard public schema"
}
schema "test" {
}
